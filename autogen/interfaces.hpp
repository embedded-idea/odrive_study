/*
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains base classes that correspond to the interfaces defined in
 * your interface file. The objects you publish should inherit from these
 * interfaces.
 *
 */
#ifndef __FIBRE_INTERFACES_HPP
#define __FIBRE_INTERFACES_HPP

#include <tuple>
using float2D = std::pair<float, float>;
struct Iph_ABC_t { float phA; float phB; float phC; };


#include <fibre/../../protocol.hpp>

#pragma GCC push_options
#pragma GCC optimize ("s")



class ODriveIntf {
public:
    class ConfigIntf {
    public:
        template<typename T> static inline auto get_enable_uart_a(T* obj) { return Property<bool>{&obj->enable_uart_a}; }
        template<typename T> static inline void get_enable_uart_a(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_uart_a}; }
        template<typename T> static inline auto get_enable_uart_b(T* obj) { return Property<bool>{&obj->enable_uart_b}; }
        template<typename T> static inline void get_enable_uart_b(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_uart_b}; }
        template<typename T> static inline auto get_enable_uart_c(T* obj) { return Property<bool>{&obj->enable_uart_c}; }
        template<typename T> static inline void get_enable_uart_c(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_uart_c}; }
        template<typename T> static inline auto get_uart_a_baudrate(T* obj) { return Property<uint32_t>{&obj->uart_a_baudrate}; }
        template<typename T> static inline void get_uart_a_baudrate(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->uart_a_baudrate}; }
        template<typename T> static inline auto get_uart_b_baudrate(T* obj) { return Property<uint32_t>{&obj->uart_b_baudrate}; }
        template<typename T> static inline void get_uart_b_baudrate(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->uart_b_baudrate}; }
        template<typename T> static inline auto get_uart_c_baudrate(T* obj) { return Property<uint32_t>{&obj->uart_c_baudrate}; }
        template<typename T> static inline void get_uart_c_baudrate(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->uart_c_baudrate}; }
        template<typename T> static inline auto get_enable_can_a(T* obj) { return Property<bool>{&obj->enable_can_a}; }
        template<typename T> static inline void get_enable_can_a(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_can_a}; }
        template<typename T> static inline auto get_enable_i2c_a(T* obj) { return Property<bool>{&obj->enable_i2c_a}; }
        template<typename T> static inline void get_enable_i2c_a(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_i2c_a}; }
        template<typename T> static inline auto get_usb_cdc_protocol(T* obj) { return Property<ODriveIntf::StreamProtocolType>{&obj->usb_cdc_protocol}; }
        template<typename T> static inline void get_usb_cdc_protocol(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::StreamProtocolType>{&obj->usb_cdc_protocol}; }
        template<typename T> static inline auto get_uart0_protocol(T* obj) { return Property<ODriveIntf::StreamProtocolType>{&obj->uart0_protocol}; }
        template<typename T> static inline void get_uart0_protocol(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::StreamProtocolType>{&obj->uart0_protocol}; }
        template<typename T> static inline auto get_uart1_protocol(T* obj) { return Property<ODriveIntf::StreamProtocolType>{&obj->uart1_protocol}; }
        template<typename T> static inline void get_uart1_protocol(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::StreamProtocolType>{&obj->uart1_protocol}; }
        template<typename T> static inline auto get_uart2_protocol(T* obj) { return Property<ODriveIntf::StreamProtocolType>{&obj->uart2_protocol}; }
        template<typename T> static inline void get_uart2_protocol(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::StreamProtocolType>{&obj->uart2_protocol}; }
        template<typename T> static inline auto get_max_regen_current(T* obj) { return Property<float>{&obj->max_regen_current}; }
        template<typename T> static inline void get_max_regen_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->max_regen_current}; }
        template<typename T> static inline auto get_brake_resistance(T* obj) { return Property<float>{&obj->brake_resistance}; }
        template<typename T> static inline void get_brake_resistance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->brake_resistance}; }
        template<typename T> static inline auto get_enable_brake_resistor(T* obj) { return Property<bool>{&obj->enable_brake_resistor}; }
        template<typename T> static inline void get_enable_brake_resistor(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_brake_resistor}; }
        template<typename T> static inline auto get_dc_bus_undervoltage_trip_level(T* obj) { return Property<float>{&obj->dc_bus_undervoltage_trip_level}; }
        template<typename T> static inline void get_dc_bus_undervoltage_trip_level(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_undervoltage_trip_level}; }
        template<typename T> static inline auto get_dc_bus_overvoltage_trip_level(T* obj) { return Property<float>{&obj->dc_bus_overvoltage_trip_level}; }
        template<typename T> static inline void get_dc_bus_overvoltage_trip_level(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_overvoltage_trip_level}; }
        template<typename T> static inline auto get_enable_dc_bus_overvoltage_ramp(T* obj) { return Property<bool>{&obj->enable_dc_bus_overvoltage_ramp}; }
        template<typename T> static inline void get_enable_dc_bus_overvoltage_ramp(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_dc_bus_overvoltage_ramp}; }
        template<typename T> static inline auto get_dc_bus_overvoltage_ramp_start(T* obj) { return Property<float>{&obj->dc_bus_overvoltage_ramp_start}; }
        template<typename T> static inline void get_dc_bus_overvoltage_ramp_start(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_overvoltage_ramp_start}; }
        template<typename T> static inline auto get_dc_bus_overvoltage_ramp_end(T* obj) { return Property<float>{&obj->dc_bus_overvoltage_ramp_end}; }
        template<typename T> static inline void get_dc_bus_overvoltage_ramp_end(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_overvoltage_ramp_end}; }
        template<typename T> static inline auto get_dc_max_positive_current(T* obj) { return Property<float>{&obj->dc_max_positive_current}; }
        template<typename T> static inline void get_dc_max_positive_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_max_positive_current}; }
        template<typename T> static inline auto get_dc_max_negative_current(T* obj) { return Property<float>{&obj->dc_max_negative_current}; }
        template<typename T> static inline void get_dc_max_negative_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_max_negative_current}; }
        template<typename T> static inline auto get_error_gpio_pin(T* obj) { return Property<uint32_t>{&obj->error_gpio_pin}; }
        template<typename T> static inline void get_error_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->error_gpio_pin}; }
        template<typename T> static inline auto get_gpio3_analog_mapping(T* obj) { return &obj->analog_mappings[3]; }
        template<typename T> static inline auto get_gpio4_analog_mapping(T* obj) { return &obj->analog_mappings[4]; }
    };
    class CanIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_baud_rate(T* obj) { return Property<uint32_t>{obj, [](void* ctx){ return (uint32_t)((T*)ctx)->baud_rate; }, [](void* ctx, uint32_t value){ ((T*)ctx)->set_baud_rate(value); }}; }
            template<typename T> static inline void get_baud_rate(T* obj, void* ptr) { new (ptr) Property<uint32_t>{obj, [](void* ctx){ return (uint32_t)((T*)ctx)->baud_rate; }, [](void* ctx, uint32_t value){ ((T*)ctx)->set_baud_rate(value); }}; }
            template<typename T> static inline auto get_protocol(T* obj) { return Property<ODriveIntf::CanIntf::Protocol>{&obj->protocol}; }
            template<typename T> static inline void get_protocol(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::CanIntf::Protocol>{&obj->protocol}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
        };
        enum Protocol {
            PROTOCOL_SIMPLE                  = 0x00000001,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::CanIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::CanIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class EndpointIntf {
    public:
        template<typename T> static inline auto get_endpoint(T* obj) { return Property<endpoint_ref_t>{&obj->endpoint}; }
        template<typename T> static inline void get_endpoint(T* obj, void* ptr) { new (ptr) Property<endpoint_ref_t>{&obj->endpoint}; }
        template<typename T> static inline auto get_min(T* obj) { return Property<float>{&obj->min}; }
        template<typename T> static inline void get_min(T* obj, void* ptr) { new (ptr) Property<float>{&obj->min}; }
        template<typename T> static inline auto get_max(T* obj) { return Property<float>{&obj->max}; }
        template<typename T> static inline void get_max(T* obj, void* ptr) { new (ptr) Property<float>{&obj->max}; }
    };
    class AxisIntf {
    public:
        class LockinConfigIntf {
        public:
            template<typename T> static inline auto get_current(T* obj) { return Property<float>{&obj->current}; }
            template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current}; }
            template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{&obj->ramp_time}; }
            template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_time}; }
            template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<float>{&obj->ramp_distance}; }
            template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_distance}; }
            template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj->accel}; }
            template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->accel}; }
            template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->vel}; }
            template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel}; }
            template<typename T> static inline auto get_finish_distance(T* obj) { return Property<float>{&obj->finish_distance}; }
            template<typename T> static inline void get_finish_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->finish_distance}; }
            template<typename T> static inline auto get_finish_on_vel(T* obj) { return Property<bool>{&obj->finish_on_vel}; }
            template<typename T> static inline void get_finish_on_vel(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->finish_on_vel}; }
            template<typename T> static inline auto get_finish_on_distance(T* obj) { return Property<bool>{&obj->finish_on_distance}; }
            template<typename T> static inline void get_finish_on_distance(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->finish_on_distance}; }
            template<typename T> static inline auto get_finish_on_enc_idx(T* obj) { return Property<bool>{&obj->finish_on_enc_idx}; }
            template<typename T> static inline void get_finish_on_enc_idx(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->finish_on_enc_idx}; }
        };
        class CanConfigIntf {
        public:
            template<typename T> static inline auto get_node_id(T* obj) { return Property<uint32_t>{&obj->node_id}; }
            template<typename T> static inline void get_node_id(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->node_id}; }
            template<typename T> static inline auto get_is_extended(T* obj) { return Property<bool>{&obj->is_extended}; }
            template<typename T> static inline void get_is_extended(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->is_extended}; }
            template<typename T> static inline auto get_heartbeat_rate_ms(T* obj) { return Property<uint32_t>{&obj->heartbeat_rate_ms}; }
            template<typename T> static inline void get_heartbeat_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->heartbeat_rate_ms}; }
            template<typename T> static inline auto get_encoder_rate_ms(T* obj) { return Property<uint32_t>{&obj->encoder_rate_ms}; }
            template<typename T> static inline void get_encoder_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->encoder_rate_ms}; }
            template<typename T> static inline auto get_motor_error_rate_ms(T* obj) { return Property<uint32_t>{&obj->motor_error_rate_ms}; }
            template<typename T> static inline void get_motor_error_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->motor_error_rate_ms}; }
            template<typename T> static inline auto get_encoder_error_rate_ms(T* obj) { return Property<uint32_t>{&obj->encoder_error_rate_ms}; }
            template<typename T> static inline void get_encoder_error_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->encoder_error_rate_ms}; }
            template<typename T> static inline auto get_controller_error_rate_ms(T* obj) { return Property<uint32_t>{&obj->controller_error_rate_ms}; }
            template<typename T> static inline void get_controller_error_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->controller_error_rate_ms}; }
            template<typename T> static inline auto get_sensorless_error_rate_ms(T* obj) { return Property<uint32_t>{&obj->sensorless_error_rate_ms}; }
            template<typename T> static inline void get_sensorless_error_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->sensorless_error_rate_ms}; }
            template<typename T> static inline auto get_encoder_count_rate_ms(T* obj) { return Property<uint32_t>{&obj->encoder_count_rate_ms}; }
            template<typename T> static inline void get_encoder_count_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->encoder_count_rate_ms}; }
            template<typename T> static inline auto get_iq_rate_ms(T* obj) { return Property<uint32_t>{&obj->iq_rate_ms}; }
            template<typename T> static inline void get_iq_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->iq_rate_ms}; }
            template<typename T> static inline auto get_sensorless_rate_ms(T* obj) { return Property<uint32_t>{&obj->sensorless_rate_ms}; }
            template<typename T> static inline void get_sensorless_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->sensorless_rate_ms}; }
            template<typename T> static inline auto get_bus_vi_rate_ms(T* obj) { return Property<uint32_t>{&obj->bus_vi_rate_ms}; }
            template<typename T> static inline void get_bus_vi_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->bus_vi_rate_ms}; }
        };
        class ConfigIntf {
        public:
            class CalibrationLockinIntf {
            public:
                template<typename T> static inline auto get_current(T* obj) { return Property<float>{&obj->current}; }
                template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current}; }
                template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{&obj->ramp_time}; }
                template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_time}; }
                template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<float>{&obj->ramp_distance}; }
                template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_distance}; }
                template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj->accel}; }
                template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->accel}; }
                template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->vel}; }
                template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel}; }
            };
            template<typename T> static inline auto get_startup_motor_calibration(T* obj) { return Property<bool>{&obj->startup_motor_calibration}; }
            template<typename T> static inline void get_startup_motor_calibration(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_motor_calibration}; }
            template<typename T> static inline auto get_startup_encoder_index_search(T* obj) { return Property<bool>{&obj->startup_encoder_index_search}; }
            template<typename T> static inline void get_startup_encoder_index_search(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_encoder_index_search}; }
            template<typename T> static inline auto get_startup_encoder_offset_calibration(T* obj) { return Property<bool>{&obj->startup_encoder_offset_calibration}; }
            template<typename T> static inline void get_startup_encoder_offset_calibration(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_encoder_offset_calibration}; }
            template<typename T> static inline auto get_startup_closed_loop_control(T* obj) { return Property<bool>{&obj->startup_closed_loop_control}; }
            template<typename T> static inline void get_startup_closed_loop_control(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_closed_loop_control}; }
            template<typename T> static inline auto get_startup_homing(T* obj) { return Property<bool>{&obj->startup_homing}; }
            template<typename T> static inline void get_startup_homing(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_homing}; }
            template<typename T> static inline auto get_enable_step_dir(T* obj) { return Property<bool>{&obj->enable_step_dir}; }
            template<typename T> static inline void get_enable_step_dir(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_step_dir}; }
            template<typename T> static inline auto get_step_dir_always_on(T* obj) { return Property<bool>{&obj->step_dir_always_on}; }
            template<typename T> static inline void get_step_dir_always_on(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->step_dir_always_on}; }
            template<typename T> static inline auto get_enable_sensorless_mode(T* obj) { return Property<bool>{&obj->enable_sensorless_mode}; }
            template<typename T> static inline void get_enable_sensorless_mode(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_sensorless_mode}; }
            template<typename T> static inline auto get_watchdog_timeout(T* obj) { return Property<float>{&obj->watchdog_timeout}; }
            template<typename T> static inline void get_watchdog_timeout(T* obj, void* ptr) { new (ptr) Property<float>{&obj->watchdog_timeout}; }
            template<typename T> static inline auto get_enable_watchdog(T* obj) { return Property<bool>{&obj->enable_watchdog}; }
            template<typename T> static inline void get_enable_watchdog(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_watchdog}; }
            template<typename T> static inline auto get_step_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->step_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_step_gpio_pin(value); }}; }
            template<typename T> static inline void get_step_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->step_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_step_gpio_pin(value); }}; }
            template<typename T> static inline auto get_dir_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->dir_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_dir_gpio_pin(value); }}; }
            template<typename T> static inline void get_dir_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->dir_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_dir_gpio_pin(value); }}; }
            template<typename T> static inline auto get_calibration_lockin(T* obj) { return &obj->calibration_lockin; }
            template<typename T> static inline auto get_sensorless_ramp(T* obj) { return &obj->sensorless_ramp; }
            template<typename T> static inline auto get_general_lockin(T* obj) { return &obj->general_lockin; }
            template<typename T> static inline auto get_can(T* obj) { return &obj->can; }
        };
        class TaskTimesIntf {
        public:
            template<typename T> static inline auto get_thermistor_update(T* obj) { return &obj->thermistor_update; }
            template<typename T> static inline auto get_encoder_update(T* obj) { return &obj->encoder_update; }
            template<typename T> static inline auto get_sensorless_estimator_update(T* obj) { return &obj->sensorless_estimator_update; }
            template<typename T> static inline auto get_endstop_update(T* obj) { return &obj->endstop_update; }
            template<typename T> static inline auto get_can_heartbeat(T* obj) { return &obj->can_heartbeat; }
            template<typename T> static inline auto get_controller_update(T* obj) { return &obj->controller_update; }
            template<typename T> static inline auto get_open_loop_controller_update(T* obj) { return &obj->open_loop_controller_update; }
            template<typename T> static inline auto get_acim_estimator_update(T* obj) { return &obj->acim_estimator_update; }
            template<typename T> static inline auto get_motor_update(T* obj) { return &obj->motor_update; }
            template<typename T> static inline auto get_current_controller_update(T* obj) { return &obj->current_controller_update; }
            template<typename T> static inline auto get_dc_calib(T* obj) { return &obj->dc_calib; }
            template<typename T> static inline auto get_current_sense(T* obj) { return &obj->current_sense; }
            template<typename T> static inline auto get_pwm_update(T* obj) { return &obj->pwm_update; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_INVALID_STATE              = 0x00000001,
            ERROR_MOTOR_FAILED               = 0x00000040,
            ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
            ERROR_ENCODER_FAILED             = 0x00000100,
            ERROR_CONTROLLER_FAILED          = 0x00000200,
            ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
            ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
            ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
            ERROR_ESTOP_REQUESTED            = 0x00004000,
            ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
            ERROR_OVER_TEMP                  = 0x00040000,
            ERROR_UNKNOWN_POSITION           = 0x00080000,
        };
        enum AxisState {
            AXIS_STATE_UNDEFINED             = 0,
            AXIS_STATE_IDLE                  = 1,
            AXIS_STATE_STARTUP_SEQUENCE      = 2,
            AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
            AXIS_STATE_MOTOR_CALIBRATION     = 4,
            AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
            AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
            AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
            AXIS_STATE_LOCKIN_SPIN           = 9,
            AXIS_STATE_ENCODER_DIR_FIND      = 10,
            AXIS_STATE_HOMING                = 11,
            AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
            AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::AxisIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::AxisIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_step_dir_active(T* obj) { return Property<const bool>{&obj->step_dir_active_}; }
        template<typename T> static inline void get_step_dir_active(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->step_dir_active_}; }
        template<typename T> static inline auto get_last_drv_fault(T* obj) { return Property<const uint32_t>{&obj->last_drv_fault_}; }
        template<typename T> static inline void get_last_drv_fault(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->last_drv_fault_}; }
        template<typename T> static inline auto get_steps(T* obj) { return Property<const int64_t>{&obj->steps_}; }
        template<typename T> static inline void get_steps(T* obj, void* ptr) { new (ptr) Property<const int64_t>{&obj->steps_}; }
        template<typename T> static inline auto get_current_state(T* obj) { return Property<const ODriveIntf::AxisIntf::AxisState>{&obj->current_state_}; }
        template<typename T> static inline void get_current_state(T* obj, void* ptr) { new (ptr) Property<const ODriveIntf::AxisIntf::AxisState>{&obj->current_state_}; }
        template<typename T> static inline auto get_requested_state(T* obj) { return Property<ODriveIntf::AxisIntf::AxisState>{&obj->requested_state_}; }
        template<typename T> static inline void get_requested_state(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::AxisIntf::AxisState>{&obj->requested_state_}; }
        template<typename T> static inline auto get_is_homed(T* obj) { return Property<bool>{&obj->homing_.is_homed}; }
        template<typename T> static inline void get_is_homed(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->homing_.is_homed}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        template<typename T> static inline auto get_motor(T* obj) { return &obj->motor_; }
        template<typename T> static inline auto get_controller(T* obj) { return &obj->controller_; }
        template<typename T> static inline auto get_encoder(T* obj) { return &obj->encoder_; }
        template<typename T> static inline auto get_acim_estimator(T* obj) { return &obj->acim_estimator_; }
        template<typename T> static inline auto get_sensorless_estimator(T* obj) { return &obj->sensorless_estimator_; }
        template<typename T> static inline auto get_trap_traj(T* obj) { return &obj->trap_traj_; }
        template<typename T> static inline auto get_min_endstop(T* obj) { return &obj->min_endstop_; }
        template<typename T> static inline auto get_max_endstop(T* obj) { return &obj->max_endstop_; }
        template<typename T> static inline auto get_mechanical_brake(T* obj) { return &obj->mechanical_brake_; }
        template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; }
        virtual void watchdog_feed() = 0;
    };
    class ThermistorCurrentLimiterIntf {
    public:
    };
    class OnboardThermistorCurrentLimiterIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<float>{&obj->temp_limit_lower}; }
            template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (ptr) Property<float>{&obj->temp_limit_lower}; }
            template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<float>{&obj->temp_limit_upper}; }
            template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (ptr) Property<float>{&obj->temp_limit_upper}; }
            template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&obj->enabled}; }
            template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enabled}; }
        };
        template<typename T> static inline auto get_temperature(T* obj) { return Property<const float>{&obj->temperature_}; }
        template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->temperature_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class OffboardThermistorCurrentLimiterIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_pin(value); }}; }
            template<typename T> static inline void get_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_pin(value); }}; }
            template<typename T> static inline auto get_poly_coefficient_0(T* obj) { return Property<float>{&obj->thermistor_poly_coeffs[0]}; }
            template<typename T> static inline void get_poly_coefficient_0(T* obj, void* ptr) { new (ptr) Property<float>{&obj->thermistor_poly_coeffs[0]}; }
            template<typename T> static inline auto get_poly_coefficient_1(T* obj) { return Property<float>{&obj->thermistor_poly_coeffs[1]}; }
            template<typename T> static inline void get_poly_coefficient_1(T* obj, void* ptr) { new (ptr) Property<float>{&obj->thermistor_poly_coeffs[1]}; }
            template<typename T> static inline auto get_poly_coefficient_2(T* obj) { return Property<float>{&obj->thermistor_poly_coeffs[2]}; }
            template<typename T> static inline void get_poly_coefficient_2(T* obj, void* ptr) { new (ptr) Property<float>{&obj->thermistor_poly_coeffs[2]}; }
            template<typename T> static inline auto get_poly_coefficient_3(T* obj) { return Property<float>{&obj->thermistor_poly_coeffs[3]}; }
            template<typename T> static inline void get_poly_coefficient_3(T* obj, void* ptr) { new (ptr) Property<float>{&obj->thermistor_poly_coeffs[3]}; }
            template<typename T> static inline auto get_temp_limit_lower(T* obj) { return Property<float>{&obj->temp_limit_lower}; }
            template<typename T> static inline void get_temp_limit_lower(T* obj, void* ptr) { new (ptr) Property<float>{&obj->temp_limit_lower}; }
            template<typename T> static inline auto get_temp_limit_upper(T* obj) { return Property<float>{&obj->temp_limit_upper}; }
            template<typename T> static inline void get_temp_limit_upper(T* obj, void* ptr) { new (ptr) Property<float>{&obj->temp_limit_upper}; }
            template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{&obj->enabled}; }
            template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enabled}; }
        };
        template<typename T> static inline auto get_temperature(T* obj) { return Property<const float>{&obj->temperature_}; }
        template<typename T> static inline void get_temperature(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->temperature_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class MotorIntf {
    public:
        class CurrentControlIntf {
        public:
            template<typename T> static inline auto get_p_gain(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pi_gains_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline void get_p_gain(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pi_gains_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline auto get_i_gain(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pi_gains_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline void get_i_gain(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pi_gains_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline auto get_I_measured_report_filter_k(T* obj) { return Property<float>{&obj->I_measured_report_filter_k_}; }
            template<typename T> static inline void get_I_measured_report_filter_k(T* obj, void* ptr) { new (ptr) Property<float>{&obj->I_measured_report_filter_k_}; }
            template<typename T> static inline auto get_Id_setpoint(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Idq_setpoint_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline void get_Id_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Idq_setpoint_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline auto get_Iq_setpoint(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Idq_setpoint_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline void get_Iq_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Idq_setpoint_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline auto get_Vd_setpoint(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Vdq_setpoint_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline void get_Vd_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Vdq_setpoint_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline auto get_Vq_setpoint(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Vdq_setpoint_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline void get_Vq_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Vdq_setpoint_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_.value_or(0.0f); }}; }
            template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_.value_or(0.0f); }}; }
            template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_vel_.value_or(0.0f); }}; }
            template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_vel_.value_or(0.0f); }}; }
            template<typename T> static inline auto get_Ialpha_measured(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Ialpha_beta_measured_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline void get_Ialpha_measured(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Ialpha_beta_measured_.value_or(float2D{0.0f, 0.0f}).first; }}; }
            template<typename T> static inline auto get_Ibeta_measured(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Ialpha_beta_measured_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline void get_Ibeta_measured(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->Ialpha_beta_measured_.value_or(float2D{0.0f, 0.0f}).second; }}; }
            template<typename T> static inline auto get_Id_measured(T* obj) { return Property<const float>{&obj->Id_measured_}; }
            template<typename T> static inline void get_Id_measured(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->Id_measured_}; }
            template<typename T> static inline auto get_Iq_measured(T* obj) { return Property<const float>{&obj->Iq_measured_}; }
            template<typename T> static inline void get_Iq_measured(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->Iq_measured_}; }
            template<typename T> static inline auto get_power(T* obj) { return Property<const float>{&obj->power_}; }
            template<typename T> static inline void get_power(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->power_}; }
            template<typename T> static inline auto get_v_current_control_integral_d(T* obj) { return Property<float>{&obj->v_current_control_integral_d_}; }
            template<typename T> static inline void get_v_current_control_integral_d(T* obj, void* ptr) { new (ptr) Property<float>{&obj->v_current_control_integral_d_}; }
            template<typename T> static inline auto get_v_current_control_integral_q(T* obj) { return Property<float>{&obj->v_current_control_integral_q_}; }
            template<typename T> static inline void get_v_current_control_integral_q(T* obj, void* ptr) { new (ptr) Property<float>{&obj->v_current_control_integral_q_}; }
            template<typename T> static inline auto get_final_v_alpha(T* obj) { return Property<const float>{&obj->final_v_alpha_}; }
            template<typename T> static inline void get_final_v_alpha(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->final_v_alpha_}; }
            template<typename T> static inline auto get_final_v_beta(T* obj) { return Property<const float>{&obj->final_v_beta_}; }
            template<typename T> static inline void get_final_v_beta(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->final_v_beta_}; }
        };
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline auto get_pole_pairs(T* obj) { return Property<int32_t>{&obj->pole_pairs}; }
            template<typename T> static inline void get_pole_pairs(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->pole_pairs}; }
            template<typename T> static inline auto get_calibration_current(T* obj) { return Property<float>{&obj->calibration_current}; }
            template<typename T> static inline void get_calibration_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calibration_current}; }
            template<typename T> static inline auto get_resistance_calib_max_voltage(T* obj) { return Property<float>{&obj->resistance_calib_max_voltage}; }
            template<typename T> static inline void get_resistance_calib_max_voltage(T* obj, void* ptr) { new (ptr) Property<float>{&obj->resistance_calib_max_voltage}; }
            template<typename T> static inline auto get_phase_inductance(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_inductance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_inductance(value); }}; }
            template<typename T> static inline void get_phase_inductance(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_inductance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_inductance(value); }}; }
            template<typename T> static inline auto get_phase_resistance(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_resistance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_resistance(value); }}; }
            template<typename T> static inline void get_phase_resistance(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_resistance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_resistance(value); }}; }
            template<typename T> static inline auto get_torque_constant(T* obj) { return Property<float>{&obj->torque_constant}; }
            template<typename T> static inline void get_torque_constant(T* obj, void* ptr) { new (ptr) Property<float>{&obj->torque_constant}; }
            template<typename T> static inline auto get_motor_type(T* obj) { return Property<ODriveIntf::MotorIntf::MotorType>{&obj->motor_type}; }
            template<typename T> static inline void get_motor_type(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::MotorIntf::MotorType>{&obj->motor_type}; }
            template<typename T> static inline auto get_current_lim(T* obj) { return Property<float>{&obj->current_lim}; }
            template<typename T> static inline void get_current_lim(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current_lim}; }
            template<typename T> static inline auto get_current_lim_margin(T* obj) { return Property<float>{&obj->current_lim_margin}; }
            template<typename T> static inline void get_current_lim_margin(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current_lim_margin}; }
            template<typename T> static inline auto get_torque_lim(T* obj) { return Property<float>{&obj->torque_lim}; }
            template<typename T> static inline void get_torque_lim(T* obj, void* ptr) { new (ptr) Property<float>{&obj->torque_lim}; }
            template<typename T> static inline auto get_inverter_temp_limit_lower(T* obj) { return Property<float>{&obj->inverter_temp_limit_lower}; }
            template<typename T> static inline void get_inverter_temp_limit_lower(T* obj, void* ptr) { new (ptr) Property<float>{&obj->inverter_temp_limit_lower}; }
            template<typename T> static inline auto get_inverter_temp_limit_upper(T* obj) { return Property<float>{&obj->inverter_temp_limit_upper}; }
            template<typename T> static inline void get_inverter_temp_limit_upper(T* obj, void* ptr) { new (ptr) Property<float>{&obj->inverter_temp_limit_upper}; }
            template<typename T> static inline auto get_requested_current_range(T* obj) { return Property<float>{&obj->requested_current_range}; }
            template<typename T> static inline void get_requested_current_range(T* obj, void* ptr) { new (ptr) Property<float>{&obj->requested_current_range}; }
            template<typename T> static inline auto get_current_control_bandwidth(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_control_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_current_control_bandwidth(value); }}; }
            template<typename T> static inline void get_current_control_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_control_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_current_control_bandwidth(value); }}; }
            template<typename T> static inline auto get_acim_gain_min_flux(T* obj) { return Property<float>{&obj->acim_gain_min_flux}; }
            template<typename T> static inline void get_acim_gain_min_flux(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_gain_min_flux}; }
            template<typename T> static inline auto get_acim_autoflux_min_Id(T* obj) { return Property<float>{&obj->acim_autoflux_min_Id}; }
            template<typename T> static inline void get_acim_autoflux_min_Id(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_autoflux_min_Id}; }
            template<typename T> static inline auto get_acim_autoflux_enable(T* obj) { return Property<bool>{&obj->acim_autoflux_enable}; }
            template<typename T> static inline void get_acim_autoflux_enable(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->acim_autoflux_enable}; }
            template<typename T> static inline auto get_acim_autoflux_attack_gain(T* obj) { return Property<float>{&obj->acim_autoflux_attack_gain}; }
            template<typename T> static inline void get_acim_autoflux_attack_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_autoflux_attack_gain}; }
            template<typename T> static inline auto get_acim_autoflux_decay_gain(T* obj) { return Property<float>{&obj->acim_autoflux_decay_gain}; }
            template<typename T> static inline void get_acim_autoflux_decay_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_autoflux_decay_gain}; }
            template<typename T> static inline auto get_R_wL_FF_enable(T* obj) { return Property<bool>{&obj->R_wL_FF_enable}; }
            template<typename T> static inline void get_R_wL_FF_enable(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->R_wL_FF_enable}; }
            template<typename T> static inline auto get_bEMF_FF_enable(T* obj) { return Property<bool>{&obj->bEMF_FF_enable}; }
            template<typename T> static inline void get_bEMF_FF_enable(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->bEMF_FF_enable}; }
            template<typename T> static inline auto get_I_bus_hard_min(T* obj) { return Property<float>{&obj->I_bus_hard_min}; }
            template<typename T> static inline void get_I_bus_hard_min(T* obj, void* ptr) { new (ptr) Property<float>{&obj->I_bus_hard_min}; }
            template<typename T> static inline auto get_I_bus_hard_max(T* obj) { return Property<float>{&obj->I_bus_hard_max}; }
            template<typename T> static inline void get_I_bus_hard_max(T* obj, void* ptr) { new (ptr) Property<float>{&obj->I_bus_hard_max}; }
            template<typename T> static inline auto get_I_leak_max(T* obj) { return Property<float>{&obj->I_leak_max}; }
            template<typename T> static inline void get_I_leak_max(T* obj, void* ptr) { new (ptr) Property<float>{&obj->I_leak_max}; }
            template<typename T> static inline auto get_dc_calib_tau(T* obj) { return Property<float>{&obj->dc_calib_tau}; }
            template<typename T> static inline void get_dc_calib_tau(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_calib_tau}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
            ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
            ERROR_DRV_FAULT                  = 0x00000008,
            ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
            ERROR_MODULATION_MAGNITUDE       = 0x00000080,
            ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
            ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
            ERROR_MODULATION_IS_NAN          = 0x00010000,
            ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
            ERROR_FET_THERMISTOR_OVER_TEMP   = 0x00040000,
            ERROR_TIMER_UPDATE_MISSED        = 0x00080000,
            ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
            ERROR_CONTROLLER_FAILED          = 0x00200000,
            ERROR_I_BUS_OUT_OF_RANGE         = 0x00400000,
            ERROR_BRAKE_RESISTOR_DISARMED    = 0x00800000,
            ERROR_SYSTEM_LEVEL               = 0x01000000,
            ERROR_BAD_TIMING                 = 0x02000000,
            ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x04000000,
            ERROR_UNKNOWN_PHASE_VEL          = 0x08000000,
            ERROR_UNKNOWN_TORQUE             = 0x10000000,
            ERROR_UNKNOWN_CURRENT_COMMAND    = 0x20000000,
            ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
            ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x80000000,
            ERROR_UNKNOWN_VOLTAGE_COMMAND    = 0x100000000,
            ERROR_UNKNOWN_GAINS              = 0x200000000,
            ERROR_CONTROLLER_INITIALIZING    = 0x400000000,
            ERROR_UNBALANCED_PHASES          = 0x800000000,
        };
        enum MotorType {
            MOTOR_TYPE_HIGH_CURRENT          = 0,
            MOTOR_TYPE_GIMBAL                = 2,
            MOTOR_TYPE_ACIM                  = 3,
        };
        template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float>{&obj->last_error_time_}; }
        template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) Property<float>{&obj->last_error_time_}; }
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::MotorIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::MotorIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_is_armed(T* obj) { return Property<const bool>{&obj->is_armed_}; }
        template<typename T> static inline void get_is_armed(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->is_armed_}; }
        template<typename T> static inline auto get_is_calibrated(T* obj) { return Property<const bool>{&obj->is_calibrated_}; }
        template<typename T> static inline void get_is_calibrated(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->is_calibrated_}; }
        template<typename T> static inline auto get_current_meas_phA(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_meas_.value_or(Iph_ABC_t{0.0f, 0.0f, 0.0f}).phA; }}; }
        template<typename T> static inline void get_current_meas_phA(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_meas_.value_or(Iph_ABC_t{0.0f, 0.0f, 0.0f}).phA; }}; }
        template<typename T> static inline auto get_current_meas_phB(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_meas_.value_or(Iph_ABC_t{0.0f, 0.0f, 0.0f}).phB; }}; }
        template<typename T> static inline void get_current_meas_phB(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_meas_.value_or(Iph_ABC_t{0.0f, 0.0f, 0.0f}).phB; }}; }
        template<typename T> static inline auto get_current_meas_phC(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_meas_.value_or(Iph_ABC_t{0.0f, 0.0f, 0.0f}).phC; }}; }
        template<typename T> static inline void get_current_meas_phC(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_meas_.value_or(Iph_ABC_t{0.0f, 0.0f, 0.0f}).phC; }}; }
        template<typename T> static inline auto get_DC_calib_phA(T* obj) { return Property<float>{&obj->DC_calib_.phA}; }
        template<typename T> static inline void get_DC_calib_phA(T* obj, void* ptr) { new (ptr) Property<float>{&obj->DC_calib_.phA}; }
        template<typename T> static inline auto get_DC_calib_phB(T* obj) { return Property<float>{&obj->DC_calib_.phB}; }
        template<typename T> static inline void get_DC_calib_phB(T* obj, void* ptr) { new (ptr) Property<float>{&obj->DC_calib_.phB}; }
        template<typename T> static inline auto get_DC_calib_phC(T* obj) { return Property<float>{&obj->DC_calib_.phC}; }
        template<typename T> static inline void get_DC_calib_phC(T* obj, void* ptr) { new (ptr) Property<float>{&obj->DC_calib_.phC}; }
        template<typename T> static inline auto get_I_bus(T* obj) { return Property<const float>{&obj->I_bus_}; }
        template<typename T> static inline void get_I_bus(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->I_bus_}; }
        template<typename T> static inline auto get_phase_current_rev_gain(T* obj) { return Property<float>{&obj->phase_current_rev_gain_}; }
        template<typename T> static inline void get_phase_current_rev_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->phase_current_rev_gain_}; }
        template<typename T> static inline auto get_effective_current_lim(T* obj) { return Property<const float>{&obj->effective_current_lim_}; }
        template<typename T> static inline void get_effective_current_lim(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->effective_current_lim_}; }
        template<typename T> static inline auto get_max_allowed_current(T* obj) { return Property<const float>{&obj->max_allowed_current_}; }
        template<typename T> static inline void get_max_allowed_current(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->max_allowed_current_}; }
        template<typename T> static inline auto get_max_dc_calib(T* obj) { return Property<const float>{&obj->max_dc_calib_}; }
        template<typename T> static inline void get_max_dc_calib(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->max_dc_calib_}; }
        template<typename T> static inline auto get_fet_thermistor(T* obj) { return &obj->fet_thermistor_; }
        template<typename T> static inline auto get_motor_thermistor(T* obj) { return &obj->motor_thermistor_; }
        template<typename T> static inline auto get_current_control(T* obj) { return &obj->current_control_; }
        template<typename T> static inline auto get_n_evt_current_measurement(T* obj) { return Property<const uint32_t>{&obj->n_evt_current_measurement_}; }
        template<typename T> static inline void get_n_evt_current_measurement(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->n_evt_current_measurement_}; }
        template<typename T> static inline auto get_n_evt_pwm_update(T* obj) { return Property<const uint32_t>{&obj->n_evt_pwm_update_}; }
        template<typename T> static inline void get_n_evt_pwm_update(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->n_evt_pwm_update_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class OscilloscopeIntf {
    public:
        template<typename T> static inline auto get_size(T* obj) { return Property<const uint32_t>{&obj->size_}; }
        template<typename T> static inline void get_size(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->size_}; }
        virtual float get_val(uint32_t index) = 0;
        uint32_t get_val_in_index_; // for internal use by Fibre
        template<typename T> static auto get_get_val_in_index_(T* obj) { return Property<uint32_t>{&obj->get_val_in_index_}; }
        template<typename T> static void get_get_val_in_index_(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->get_val_in_index_}; }
        float get_val_out_val_; // for internal use by Fibre
        template<typename T> static auto get_get_val_out_val_(T* obj) { return Property<const float>{&obj->get_val_out_val_}; }
        template<typename T> static void get_get_val_out_val_(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->get_val_out_val_}; }
    };
    class AcimEstimatorIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_slip_velocity(T* obj) { return Property<float>{&obj->slip_velocity}; }
            template<typename T> static inline void get_slip_velocity(T* obj, void* ptr) { new (ptr) Property<float>{&obj->slip_velocity}; }
        };
        template<typename T> static inline auto get_rotor_flux(T* obj) { return Property<const float>{&obj->rotor_flux_}; }
        template<typename T> static inline void get_rotor_flux(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->rotor_flux_}; }
        template<typename T> static inline auto get_slip_vel(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->slip_vel_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_slip_vel(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->slip_vel_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_phase_offset(T* obj) { return Property<const float>{&obj->phase_offset_}; }
        template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->phase_offset_}; }
        template<typename T> static inline auto get_stator_phase_vel(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->stator_phase_vel_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_stator_phase_vel(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->stator_phase_vel_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_stator_phase(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->stator_phase_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_stator_phase(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->stator_phase_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class ControllerIntf {
    public:
        class ConfigIntf {
        public:
            class AnticoggingIntf {
            public:
                template<typename T> static inline auto get_index(T* obj) { return Property<const uint32_t>{&obj->index}; }
                template<typename T> static inline void get_index(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->index}; }
                template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bool>{&obj->pre_calibrated}; }
                template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->pre_calibrated}; }
                template<typename T> static inline auto get_calib_anticogging(T* obj) { return Property<const bool>{&obj->calib_anticogging}; }
                template<typename T> static inline void get_calib_anticogging(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->calib_anticogging}; }
                template<typename T> static inline auto get_calib_pos_threshold(T* obj) { return Property<float>{&obj->calib_pos_threshold}; }
                template<typename T> static inline void get_calib_pos_threshold(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_pos_threshold}; }
                template<typename T> static inline auto get_calib_vel_threshold(T* obj) { return Property<float>{&obj->calib_vel_threshold}; }
                template<typename T> static inline void get_calib_vel_threshold(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_vel_threshold}; }
                template<typename T> static inline auto get_cogging_ratio(T* obj) { return Property<const float>{&obj->cogging_ratio}; }
                template<typename T> static inline void get_cogging_ratio(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->cogging_ratio}; }
                template<typename T> static inline auto get_anticogging_enabled(T* obj) { return Property<bool>{&obj->anticogging_enabled}; }
                template<typename T> static inline void get_anticogging_enabled(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->anticogging_enabled}; }
            };
            template<typename T> static inline auto get_gain_scheduling_width(T* obj) { return Property<float>{&obj->gain_scheduling_width}; }
            template<typename T> static inline void get_gain_scheduling_width(T* obj, void* ptr) { new (ptr) Property<float>{&obj->gain_scheduling_width}; }
            template<typename T> static inline auto get_enable_vel_limit(T* obj) { return Property<bool>{&obj->enable_vel_limit}; }
            template<typename T> static inline void get_enable_vel_limit(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_vel_limit}; }
            template<typename T> static inline auto get_enable_torque_mode_vel_limit(T* obj) { return Property<bool>{&obj->enable_torque_mode_vel_limit}; }
            template<typename T> static inline void get_enable_torque_mode_vel_limit(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_torque_mode_vel_limit}; }
            template<typename T> static inline auto get_enable_gain_scheduling(T* obj) { return Property<bool>{&obj->enable_gain_scheduling}; }
            template<typename T> static inline void get_enable_gain_scheduling(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_gain_scheduling}; }
            template<typename T> static inline auto get_enable_overspeed_error(T* obj) { return Property<bool>{&obj->enable_overspeed_error}; }
            template<typename T> static inline void get_enable_overspeed_error(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_overspeed_error}; }
            template<typename T> static inline auto get_control_mode(T* obj) { return Property<ODriveIntf::ControllerIntf::ControlMode>{obj, [](void* ctx){ return (ODriveIntf::ControllerIntf::ControlMode)((T*)ctx)->control_mode; }, [](void* ctx, ODriveIntf::ControllerIntf::ControlMode value){ ((T*)ctx)->set_control_mode(value); }}; }
            template<typename T> static inline void get_control_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::ControllerIntf::ControlMode>{obj, [](void* ctx){ return (ODriveIntf::ControllerIntf::ControlMode)((T*)ctx)->control_mode; }, [](void* ctx, ODriveIntf::ControllerIntf::ControlMode value){ ((T*)ctx)->set_control_mode(value); }}; }
            template<typename T> static inline auto get_input_mode(T* obj) { return Property<ODriveIntf::ControllerIntf::InputMode>{&obj->input_mode}; }
            template<typename T> static inline void get_input_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::ControllerIntf::InputMode>{&obj->input_mode}; }
            template<typename T> static inline auto get_pos_gain(T* obj) { return Property<float>{&obj->pos_gain}; }
            template<typename T> static inline void get_pos_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pos_gain}; }
            template<typename T> static inline auto get_vel_gain(T* obj) { return Property<float>{&obj->vel_gain}; }
            template<typename T> static inline void get_vel_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_gain}; }
            template<typename T> static inline auto get_vel_integrator_gain(T* obj) { return Property<float>{&obj->vel_integrator_gain}; }
            template<typename T> static inline void get_vel_integrator_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_integrator_gain}; }
            template<typename T> static inline auto get_vel_integrator_limit(T* obj) { return Property<float>{&obj->vel_integrator_limit}; }
            template<typename T> static inline void get_vel_integrator_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_integrator_limit}; }
            template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{&obj->vel_limit}; }
            template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_limit}; }
            template<typename T> static inline auto get_vel_limit_tolerance(T* obj) { return Property<float>{&obj->vel_limit_tolerance}; }
            template<typename T> static inline void get_vel_limit_tolerance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_limit_tolerance}; }
            template<typename T> static inline auto get_vel_ramp_rate(T* obj) { return Property<float>{&obj->vel_ramp_rate}; }
            template<typename T> static inline void get_vel_ramp_rate(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_ramp_rate}; }
            template<typename T> static inline auto get_torque_ramp_rate(T* obj) { return Property<float>{&obj->torque_ramp_rate}; }
            template<typename T> static inline void get_torque_ramp_rate(T* obj, void* ptr) { new (ptr) Property<float>{&obj->torque_ramp_rate}; }
            template<typename T> static inline auto get_circular_setpoints(T* obj) { return Property<bool>{&obj->circular_setpoints}; }
            template<typename T> static inline void get_circular_setpoints(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->circular_setpoints}; }
            template<typename T> static inline auto get_circular_setpoint_range(T* obj) { return Property<float>{&obj->circular_setpoint_range}; }
            template<typename T> static inline void get_circular_setpoint_range(T* obj, void* ptr) { new (ptr) Property<float>{&obj->circular_setpoint_range}; }
            template<typename T> static inline auto get_steps_per_circular_range(T* obj) { return Property<int32_t>{obj, [](void* ctx){ return (int32_t)((T*)ctx)->steps_per_circular_range; }, [](void* ctx, int32_t value){ ((T*)ctx)->set_steps_per_circular_range(value); }}; }
            template<typename T> static inline void get_steps_per_circular_range(T* obj, void* ptr) { new (ptr) Property<int32_t>{obj, [](void* ctx){ return (int32_t)((T*)ctx)->steps_per_circular_range; }, [](void* ctx, int32_t value){ ((T*)ctx)->set_steps_per_circular_range(value); }}; }
            template<typename T> static inline auto get_homing_speed(T* obj) { return Property<float>{&obj->homing_speed}; }
            template<typename T> static inline void get_homing_speed(T* obj, void* ptr) { new (ptr) Property<float>{&obj->homing_speed}; }
            template<typename T> static inline auto get_inertia(T* obj) { return Property<float>{&obj->inertia}; }
            template<typename T> static inline void get_inertia(T* obj, void* ptr) { new (ptr) Property<float>{&obj->inertia}; }
            template<typename T> static inline auto get_axis_to_mirror(T* obj) { return Property<uint8_t>{&obj->axis_to_mirror}; }
            template<typename T> static inline void get_axis_to_mirror(T* obj, void* ptr) { new (ptr) Property<uint8_t>{&obj->axis_to_mirror}; }
            template<typename T> static inline auto get_mirror_ratio(T* obj) { return Property<float>{&obj->mirror_ratio}; }
            template<typename T> static inline void get_mirror_ratio(T* obj, void* ptr) { new (ptr) Property<float>{&obj->mirror_ratio}; }
            template<typename T> static inline auto get_torque_mirror_ratio(T* obj) { return Property<float>{&obj->torque_mirror_ratio}; }
            template<typename T> static inline void get_torque_mirror_ratio(T* obj, void* ptr) { new (ptr) Property<float>{&obj->torque_mirror_ratio}; }
            template<typename T> static inline auto get_load_encoder_axis(T* obj) { return Property<uint8_t>{&obj->load_encoder_axis}; }
            template<typename T> static inline void get_load_encoder_axis(T* obj, void* ptr) { new (ptr) Property<uint8_t>{&obj->load_encoder_axis}; }
            template<typename T> static inline auto get_input_filter_bandwidth(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_filter_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_input_filter_bandwidth(value); }}; }
            template<typename T> static inline void get_input_filter_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_filter_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_input_filter_bandwidth(value); }}; }
            template<typename T> static inline auto get_anticogging(T* obj) { return &obj->anticogging; }
            template<typename T> static inline auto get_mechanical_power_bandwidth(T* obj) { return Property<float>{&obj->mechanical_power_bandwidth}; }
            template<typename T> static inline void get_mechanical_power_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{&obj->mechanical_power_bandwidth}; }
            template<typename T> static inline auto get_electrical_power_bandwidth(T* obj) { return Property<float>{&obj->electrical_power_bandwidth}; }
            template<typename T> static inline void get_electrical_power_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{&obj->electrical_power_bandwidth}; }
            template<typename T> static inline auto get_spinout_mechanical_power_threshold(T* obj) { return Property<float>{&obj->spinout_mechanical_power_threshold}; }
            template<typename T> static inline void get_spinout_mechanical_power_threshold(T* obj, void* ptr) { new (ptr) Property<float>{&obj->spinout_mechanical_power_threshold}; }
            template<typename T> static inline auto get_spinout_electrical_power_threshold(T* obj) { return Property<float>{&obj->spinout_electrical_power_threshold}; }
            template<typename T> static inline void get_spinout_electrical_power_threshold(T* obj, void* ptr) { new (ptr) Property<float>{&obj->spinout_electrical_power_threshold}; }
        };
        class AutotuningIntf {
        public:
            template<typename T> static inline auto get_frequency(T* obj) { return Property<float>{&obj->frequency}; }
            template<typename T> static inline void get_frequency(T* obj, void* ptr) { new (ptr) Property<float>{&obj->frequency}; }
            template<typename T> static inline auto get_pos_amplitude(T* obj) { return Property<float>{&obj->pos_amplitude}; }
            template<typename T> static inline void get_pos_amplitude(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pos_amplitude}; }
            template<typename T> static inline auto get_vel_amplitude(T* obj) { return Property<float>{&obj->vel_amplitude}; }
            template<typename T> static inline void get_vel_amplitude(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_amplitude}; }
            template<typename T> static inline auto get_torque_amplitude(T* obj) { return Property<float>{&obj->torque_amplitude}; }
            template<typename T> static inline void get_torque_amplitude(T* obj, void* ptr) { new (ptr) Property<float>{&obj->torque_amplitude}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_OVERSPEED                  = 0x00000001,
            ERROR_INVALID_INPUT_MODE         = 0x00000002,
            ERROR_UNSTABLE_GAIN              = 0x00000004,
            ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
            ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
            ERROR_INVALID_ESTIMATE           = 0x00000020,
            ERROR_INVALID_CIRCULAR_RANGE     = 0x00000040,
            ERROR_SPINOUT_DETECTED           = 0x00000080,
        };
        enum ControlMode {
            CONTROL_MODE_VOLTAGE_CONTROL     = 0,
            CONTROL_MODE_TORQUE_CONTROL      = 1,
            CONTROL_MODE_VELOCITY_CONTROL    = 2,
            CONTROL_MODE_POSITION_CONTROL    = 3,
        };
        enum InputMode {
            INPUT_MODE_INACTIVE              = 0,
            INPUT_MODE_PASSTHROUGH           = 1,
            INPUT_MODE_VEL_RAMP              = 2,
            INPUT_MODE_POS_FILTER            = 3,
            INPUT_MODE_MIX_CHANNELS          = 4,
            INPUT_MODE_TRAP_TRAJ             = 5,
            INPUT_MODE_TORQUE_RAMP           = 6,
            INPUT_MODE_MIRROR                = 7,
            INPUT_MODE_TUNING                = 8,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::ControllerIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::ControllerIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_last_error_time(T* obj) { return Property<float>{&obj->last_error_time_}; }
        template<typename T> static inline void get_last_error_time(T* obj, void* ptr) { new (ptr) Property<float>{&obj->last_error_time_}; }
        template<typename T> static inline auto get_input_pos(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_pos_; }, [](void* ctx, float value){ ((T*)ctx)->set_input_pos(value); }}; }
        template<typename T> static inline void get_input_pos(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_pos_; }, [](void* ctx, float value){ ((T*)ctx)->set_input_pos(value); }}; }
        template<typename T> static inline auto get_input_vel(T* obj) { return Property<float>{&obj->input_vel_}; }
        template<typename T> static inline void get_input_vel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->input_vel_}; }
        template<typename T> static inline auto get_input_torque(T* obj) { return Property<float>{&obj->input_torque_}; }
        template<typename T> static inline void get_input_torque(T* obj, void* ptr) { new (ptr) Property<float>{&obj->input_torque_}; }
        template<typename T> static inline auto get_pos_setpoint(T* obj) { return Property<const float>{&obj->pos_setpoint_}; }
        template<typename T> static inline void get_pos_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->pos_setpoint_}; }
        template<typename T> static inline auto get_vel_setpoint(T* obj) { return Property<const float>{&obj->vel_setpoint_}; }
        template<typename T> static inline void get_vel_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->vel_setpoint_}; }
        template<typename T> static inline auto get_torque_setpoint(T* obj) { return Property<const float>{&obj->torque_setpoint_}; }
        template<typename T> static inline void get_torque_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->torque_setpoint_}; }
        template<typename T> static inline auto get_trajectory_done(T* obj) { return Property<const bool>{&obj->trajectory_done_}; }
        template<typename T> static inline void get_trajectory_done(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->trajectory_done_}; }
        template<typename T> static inline auto get_vel_integrator_torque(T* obj) { return Property<float>{&obj->vel_integrator_torque_}; }
        template<typename T> static inline void get_vel_integrator_torque(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_integrator_torque_}; }
        template<typename T> static inline auto get_anticogging_valid(T* obj) { return Property<bool>{&obj->anticogging_valid_}; }
        template<typename T> static inline void get_anticogging_valid(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->anticogging_valid_}; }
        template<typename T> static inline auto get_autotuning_phase(T* obj) { return Property<float>{&obj->autotuning_phase_}; }
        template<typename T> static inline void get_autotuning_phase(T* obj, void* ptr) { new (ptr) Property<float>{&obj->autotuning_phase_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        template<typename T> static inline auto get_autotuning(T* obj) { return &obj->autotuning_; }
        template<typename T> static inline auto get_mechanical_power(T* obj) { return Property<const float>{&obj->mechanical_power_}; }
        template<typename T> static inline void get_mechanical_power(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->mechanical_power_}; }
        template<typename T> static inline auto get_electrical_power(T* obj) { return Property<const float>{&obj->electrical_power_}; }
        template<typename T> static inline void get_electrical_power(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->electrical_power_}; }
        virtual void move_incremental(float displacement, bool from_input_pos) = 0;
        virtual void start_anticogging_calibration() = 0;
        virtual float remove_anticogging_bias() = 0;
        virtual float get_anticogging_value(uint32_t index) = 0;
        float move_incremental_in_displacement_; // for internal use by Fibre
        template<typename T> static auto get_move_incremental_in_displacement_(T* obj) { return Property<float>{&obj->move_incremental_in_displacement_}; }
        template<typename T> static void get_move_incremental_in_displacement_(T* obj, void* ptr) { new (ptr) Property<float>{&obj->move_incremental_in_displacement_}; }
        bool move_incremental_in_from_input_pos_; // for internal use by Fibre
        template<typename T> static auto get_move_incremental_in_from_input_pos_(T* obj) { return Property<bool>{&obj->move_incremental_in_from_input_pos_}; }
        template<typename T> static void get_move_incremental_in_from_input_pos_(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->move_incremental_in_from_input_pos_}; }
        float remove_anticogging_bias_out_val_; // for internal use by Fibre
        template<typename T> static auto get_remove_anticogging_bias_out_val_(T* obj) { return Property<const float>{&obj->remove_anticogging_bias_out_val_}; }
        template<typename T> static void get_remove_anticogging_bias_out_val_(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->remove_anticogging_bias_out_val_}; }
        uint32_t get_anticogging_value_in_index_; // for internal use by Fibre
        template<typename T> static auto get_get_anticogging_value_in_index_(T* obj) { return Property<uint32_t>{&obj->get_anticogging_value_in_index_}; }
        template<typename T> static void get_get_anticogging_value_in_index_(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->get_anticogging_value_in_index_}; }
        float get_anticogging_value_out_val_; // for internal use by Fibre
        template<typename T> static auto get_get_anticogging_value_out_val_(T* obj) { return Property<const float>{&obj->get_anticogging_value_out_val_}; }
        template<typename T> static void get_get_anticogging_value_out_val_(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->get_anticogging_value_out_val_}; }
    };
    class EncoderIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_mode(T* obj) { return Property<ODriveIntf::EncoderIntf::Mode>{&obj->mode}; }
            template<typename T> static inline void get_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::EncoderIntf::Mode>{&obj->mode}; }
            template<typename T> static inline auto get_use_index(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->use_index; }, [](void* ctx, bool value){ ((T*)ctx)->set_use_index(value); }}; }
            template<typename T> static inline void get_use_index(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->use_index; }, [](void* ctx, bool value){ ((T*)ctx)->set_use_index(value); }}; }
            template<typename T> static inline auto get_index_offset(T* obj) { return Property<float>{&obj->index_offset}; }
            template<typename T> static inline void get_index_offset(T* obj, void* ptr) { new (ptr) Property<float>{&obj->index_offset}; }
            template<typename T> static inline auto get_use_index_offset(T* obj) { return Property<bool>{&obj->use_index_offset}; }
            template<typename T> static inline void get_use_index_offset(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->use_index_offset}; }
            template<typename T> static inline auto get_find_idx_on_lockin_only(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->find_idx_on_lockin_only; }, [](void* ctx, bool value){ ((T*)ctx)->set_find_idx_on_lockin_only(value); }}; }
            template<typename T> static inline void get_find_idx_on_lockin_only(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->find_idx_on_lockin_only; }, [](void* ctx, bool value){ ((T*)ctx)->set_find_idx_on_lockin_only(value); }}; }
            template<typename T> static inline auto get_abs_spi_cs_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->abs_spi_cs_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_abs_spi_cs_gpio_pin(value); }}; }
            template<typename T> static inline void get_abs_spi_cs_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->abs_spi_cs_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_abs_spi_cs_gpio_pin(value); }}; }
            template<typename T> static inline auto get_cpr(T* obj) { return Property<int32_t>{&obj->cpr}; }
            template<typename T> static inline void get_cpr(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->cpr}; }
            template<typename T> static inline auto get_phase_offset(T* obj) { return Property<int32_t>{&obj->phase_offset}; }
            template<typename T> static inline void get_phase_offset(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->phase_offset}; }
            template<typename T> static inline auto get_phase_offset_float(T* obj) { return Property<float>{&obj->phase_offset_float}; }
            template<typename T> static inline void get_phase_offset_float(T* obj, void* ptr) { new (ptr) Property<float>{&obj->phase_offset_float}; }
            template<typename T> static inline auto get_direction(T* obj) { return Property<int32_t>{&obj->direction}; }
            template<typename T> static inline void get_direction(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->direction}; }
            template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline auto get_enable_phase_interpolation(T* obj) { return Property<bool>{&obj->enable_phase_interpolation}; }
            template<typename T> static inline void get_enable_phase_interpolation(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_phase_interpolation}; }
            template<typename T> static inline auto get_bandwidth(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_bandwidth(value); }}; }
            template<typename T> static inline void get_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_bandwidth(value); }}; }
            template<typename T> static inline auto get_calib_range(T* obj) { return Property<float>{&obj->calib_range}; }
            template<typename T> static inline void get_calib_range(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_range}; }
            template<typename T> static inline auto get_calib_scan_distance(T* obj) { return Property<float>{&obj->calib_scan_distance}; }
            template<typename T> static inline void get_calib_scan_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_scan_distance}; }
            template<typename T> static inline auto get_calib_scan_omega(T* obj) { return Property<float>{&obj->calib_scan_omega}; }
            template<typename T> static inline void get_calib_scan_omega(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_scan_omega}; }
            template<typename T> static inline auto get_ignore_illegal_hall_state(T* obj) { return Property<bool>{&obj->ignore_illegal_hall_state}; }
            template<typename T> static inline void get_ignore_illegal_hall_state(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->ignore_illegal_hall_state}; }
            template<typename T> static inline auto get_hall_polarity(T* obj) { return Property<uint8_t>{&obj->hall_polarity}; }
            template<typename T> static inline void get_hall_polarity(T* obj, void* ptr) { new (ptr) Property<uint8_t>{&obj->hall_polarity}; }
            template<typename T> static inline auto get_hall_polarity_calibrated(T* obj) { return Property<bool>{&obj->hall_polarity_calibrated}; }
            template<typename T> static inline void get_hall_polarity_calibrated(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->hall_polarity_calibrated}; }
            template<typename T> static inline auto get_sincos_gpio_pin_sin(T* obj) { return Property<uint16_t>{&obj->sincos_gpio_pin_sin}; }
            template<typename T> static inline void get_sincos_gpio_pin_sin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{&obj->sincos_gpio_pin_sin}; }
            template<typename T> static inline auto get_sincos_gpio_pin_cos(T* obj) { return Property<uint16_t>{&obj->sincos_gpio_pin_cos}; }
            template<typename T> static inline void get_sincos_gpio_pin_cos(T* obj, void* ptr) { new (ptr) Property<uint16_t>{&obj->sincos_gpio_pin_cos}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_UNSTABLE_GAIN              = 0x00000001,
            ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
            ERROR_NO_RESPONSE                = 0x00000004,
            ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
            ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
            ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
            ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
            ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
            ERROR_ABS_SPI_NOT_READY          = 0x00000100,
            ERROR_HALL_NOT_CALIBRATED_YET    = 0x00000200,
        };
        enum Mode {
            MODE_INCREMENTAL                 = 0,
            MODE_HALL                        = 1,
            MODE_SINCOS                      = 2,
            MODE_SPI_ABS_CUI                 = 256,
            MODE_SPI_ABS_AMS                 = 257,
            MODE_SPI_ABS_AEAT                = 258,
            MODE_SPI_ABS_RLS                 = 259,
            MODE_SPI_ABS_MA732               = 260,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::EncoderIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::EncoderIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_is_ready(T* obj) { return Property<const bool>{&obj->is_ready_}; }
        template<typename T> static inline void get_is_ready(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->is_ready_}; }
        template<typename T> static inline auto get_index_found(T* obj) { return Property<const bool>{&obj->index_found_}; }
        template<typename T> static inline void get_index_found(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->index_found_}; }
        template<typename T> static inline auto get_shadow_count(T* obj) { return Property<const int32_t>{&obj->shadow_count_}; }
        template<typename T> static inline void get_shadow_count(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->shadow_count_}; }
        template<typename T> static inline auto get_count_in_cpr(T* obj) { return Property<const int32_t>{&obj->count_in_cpr_}; }
        template<typename T> static inline void get_count_in_cpr(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->count_in_cpr_}; }
        template<typename T> static inline auto get_interpolation(T* obj) { return Property<const float>{&obj->interpolation_}; }
        template<typename T> static inline void get_interpolation(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->interpolation_}; }
        template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_pos_estimate(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pos_estimate_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_pos_estimate(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pos_estimate_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_pos_estimate_counts(T* obj) { return Property<const float>{&obj->pos_estimate_counts_}; }
        template<typename T> static inline void get_pos_estimate_counts(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->pos_estimate_counts_}; }
        template<typename T> static inline auto get_pos_circular(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pos_circular_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_pos_circular(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->pos_circular_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_pos_cpr_counts(T* obj) { return Property<const float>{&obj->pos_cpr_counts_}; }
        template<typename T> static inline void get_pos_cpr_counts(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->pos_cpr_counts_}; }
        template<typename T> static inline auto get_delta_pos_cpr_counts(T* obj) { return Property<const float>{&obj->delta_pos_cpr_counts_}; }
        template<typename T> static inline void get_delta_pos_cpr_counts(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->delta_pos_cpr_counts_}; }
        template<typename T> static inline auto get_hall_state(T* obj) { return Property<const uint8_t>{&obj->hall_state_}; }
        template<typename T> static inline void get_hall_state(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hall_state_}; }
        template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->vel_estimate_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->vel_estimate_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_vel_estimate_counts(T* obj) { return Property<const float>{&obj->vel_estimate_counts_}; }
        template<typename T> static inline void get_vel_estimate_counts(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->vel_estimate_counts_}; }
        template<typename T> static inline auto get_calib_scan_response(T* obj) { return Property<const float>{&obj->calib_scan_response_}; }
        template<typename T> static inline void get_calib_scan_response(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->calib_scan_response_}; }
        template<typename T> static inline auto get_pos_abs(T* obj) { return Property<int32_t>{&obj->pos_abs_}; }
        template<typename T> static inline void get_pos_abs(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->pos_abs_}; }
        template<typename T> static inline auto get_spi_error_rate(T* obj) { return Property<const float>{&obj->spi_error_rate_}; }
        template<typename T> static inline void get_spi_error_rate(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->spi_error_rate_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        virtual void set_linear_count(int32_t count) = 0;
        int32_t set_linear_count_in_count_; // for internal use by Fibre
        template<typename T> static auto get_set_linear_count_in_count_(T* obj) { return Property<int32_t>{&obj->set_linear_count_in_count_}; }
        template<typename T> static void get_set_linear_count_in_count_(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->set_linear_count_in_count_}; }
    };
    class SensorlessEstimatorIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_observer_gain(T* obj) { return Property<float>{&obj->observer_gain}; }
            template<typename T> static inline void get_observer_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->observer_gain}; }
            template<typename T> static inline auto get_pll_bandwidth(T* obj) { return Property<float>{&obj->pll_bandwidth}; }
            template<typename T> static inline void get_pll_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pll_bandwidth}; }
            template<typename T> static inline auto get_pm_flux_linkage(T* obj) { return Property<float>{&obj->pm_flux_linkage}; }
            template<typename T> static inline void get_pm_flux_linkage(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pm_flux_linkage}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_UNSTABLE_GAIN              = 0x00000001,
            ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::SensorlessEstimatorIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::SensorlessEstimatorIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_pll_pos(T* obj) { return Property<const float>{&obj->pll_pos_}; }
        template<typename T> static inline void get_pll_pos(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->pll_pos_}; }
        template<typename T> static inline auto get_phase_vel(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_vel_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_phase_vel(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_vel_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->vel_estimate_.any().value_or(0.0f); }}; }
        template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Property<const float>{obj, [](void* ctx){ return (float)((T*)ctx)->vel_estimate_.any().value_or(0.0f); }}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class TrapezoidalTrajectoryIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{&obj->vel_limit}; }
            template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_limit}; }
            template<typename T> static inline auto get_accel_limit(T* obj) { return Property<float>{&obj->accel_limit}; }
            template<typename T> static inline void get_accel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->accel_limit}; }
            template<typename T> static inline auto get_decel_limit(T* obj) { return Property<float>{&obj->decel_limit}; }
            template<typename T> static inline void get_decel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->decel_limit}; }
        };
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class EndstopIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_num; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_num(value); }}; }
            template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_num; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_num(value); }}; }
            template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->enabled; }, [](void* ctx, bool value){ ((T*)ctx)->set_enabled(value); }}; }
            template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->enabled; }, [](void* ctx, bool value){ ((T*)ctx)->set_enabled(value); }}; }
            template<typename T> static inline auto get_offset(T* obj) { return Property<float>{&obj->offset}; }
            template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Property<float>{&obj->offset}; }
            template<typename T> static inline auto get_is_active_high(T* obj) { return Property<bool>{&obj->is_active_high}; }
            template<typename T> static inline void get_is_active_high(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->is_active_high}; }
            template<typename T> static inline auto get_debounce_ms(T* obj) { return Property<uint32_t>{obj, [](void* ctx){ return (uint32_t)((T*)ctx)->debounce_ms; }, [](void* ctx, uint32_t value){ ((T*)ctx)->set_debounce_ms(value); }}; }
            template<typename T> static inline void get_debounce_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{obj, [](void* ctx){ return (uint32_t)((T*)ctx)->debounce_ms; }, [](void* ctx, uint32_t value){ ((T*)ctx)->set_debounce_ms(value); }}; }
        };
        template<typename T> static inline auto get_endstop_state(T* obj) { return Property<const bool>{&obj->endstop_state_}; }
        template<typename T> static inline void get_endstop_state(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->endstop_state_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class MechanicalBrakeIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_num; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_num(value); }}; }
            template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_num; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_num(value); }}; }
            template<typename T> static inline auto get_is_active_low(T* obj) { return Property<bool>{&obj->is_active_low}; }
            template<typename T> static inline void get_is_active_low(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->is_active_low}; }
        };
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        virtual void engage() = 0;
        virtual void release() = 0;
    };
    class TaskTimerIntf {
    public:
        template<typename T> static inline auto get_start_time(T* obj) { return Property<const uint32_t>{&obj->start_time_}; }
        template<typename T> static inline void get_start_time(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->start_time_}; }
        template<typename T> static inline auto get_end_time(T* obj) { return Property<const uint32_t>{&obj->end_time_}; }
        template<typename T> static inline void get_end_time(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->end_time_}; }
        template<typename T> static inline auto get_length(T* obj) { return Property<const uint32_t>{&obj->length_}; }
        template<typename T> static inline void get_length(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->length_}; }
        template<typename T> static inline auto get_max_length(T* obj) { return Property<uint32_t>{&obj->max_length_}; }
        template<typename T> static inline void get_max_length(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->max_length_}; }
    };
    class TaskTimesIntf {
    public:
        template<typename T> static inline auto get_sampling(T* obj) { return &obj->sampling; }
        template<typename T> static inline auto get_control_loop_misc(T* obj) { return &obj->control_loop_misc; }
        template<typename T> static inline auto get_control_loop_checks(T* obj) { return &obj->control_loop_checks; }
        template<typename T> static inline auto get_dc_calib_wait(T* obj) { return &obj->dc_calib_wait; }
    };
    class SystemStatsIntf {
    public:
        class UsbIntf {
        public:
            template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline auto get_tx_cnt(T* obj) { return Property<const uint32_t>{&obj->tx_cnt}; }
            template<typename T> static inline void get_tx_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->tx_cnt}; }
            template<typename T> static inline auto get_tx_overrun_cnt(T* obj) { return Property<const uint32_t>{&obj->tx_overrun_cnt}; }
            template<typename T> static inline void get_tx_overrun_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->tx_overrun_cnt}; }
        };
        class I2CIntf {
        public:
            template<typename T> static inline auto get_addr(T* obj) { return Property<const uint8_t>{&obj->addr}; }
            template<typename T> static inline void get_addr(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->addr}; }
            template<typename T> static inline auto get_addr_match_cnt(T* obj) { return Property<const uint32_t>{&obj->addr_match_cnt}; }
            template<typename T> static inline void get_addr_match_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->addr_match_cnt}; }
            template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline auto get_error_cnt(T* obj) { return Property<const uint32_t>{&obj->error_cnt}; }
            template<typename T> static inline void get_error_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->error_cnt}; }
        };
        template<typename T> static inline auto get_uptime(T* obj) { return Property<const uint32_t>{&obj->uptime}; }
        template<typename T> static inline void get_uptime(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->uptime}; }
        template<typename T> static inline auto get_min_heap_space(T* obj) { return Property<const uint32_t>{&obj->min_heap_space}; }
        template<typename T> static inline void get_min_heap_space(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_heap_space}; }
        template<typename T> static inline auto get_max_stack_usage_axis(T* obj) { return Property<const uint32_t>{&obj->max_stack_usage_axis}; }
        template<typename T> static inline void get_max_stack_usage_axis(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->max_stack_usage_axis}; }
        template<typename T> static inline auto get_max_stack_usage_usb(T* obj) { return Property<const uint32_t>{&obj->max_stack_usage_usb}; }
        template<typename T> static inline void get_max_stack_usage_usb(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->max_stack_usage_usb}; }
        template<typename T> static inline auto get_max_stack_usage_uart(T* obj) { return Property<const uint32_t>{&obj->max_stack_usage_uart}; }
        template<typename T> static inline void get_max_stack_usage_uart(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->max_stack_usage_uart}; }
        template<typename T> static inline auto get_max_stack_usage_can(T* obj) { return Property<const uint32_t>{&obj->max_stack_usage_can}; }
        template<typename T> static inline void get_max_stack_usage_can(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->max_stack_usage_can}; }
        template<typename T> static inline auto get_max_stack_usage_startup(T* obj) { return Property<const uint32_t>{&obj->max_stack_usage_startup}; }
        template<typename T> static inline void get_max_stack_usage_startup(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->max_stack_usage_startup}; }
        template<typename T> static inline auto get_max_stack_usage_analog(T* obj) { return Property<const uint32_t>{&obj->max_stack_usage_analog}; }
        template<typename T> static inline void get_max_stack_usage_analog(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->max_stack_usage_analog}; }
        template<typename T> static inline auto get_stack_size_axis(T* obj) { return Property<const uint32_t>{&obj->stack_size_axis}; }
        template<typename T> static inline void get_stack_size_axis(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_size_axis}; }
        template<typename T> static inline auto get_stack_size_usb(T* obj) { return Property<const uint32_t>{&obj->stack_size_usb}; }
        template<typename T> static inline void get_stack_size_usb(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_size_usb}; }
        template<typename T> static inline auto get_stack_size_uart(T* obj) { return Property<const uint32_t>{&obj->stack_size_uart}; }
        template<typename T> static inline void get_stack_size_uart(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_size_uart}; }
        template<typename T> static inline auto get_stack_size_startup(T* obj) { return Property<const uint32_t>{&obj->stack_size_startup}; }
        template<typename T> static inline void get_stack_size_startup(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_size_startup}; }
        template<typename T> static inline auto get_stack_size_can(T* obj) { return Property<const uint32_t>{&obj->stack_size_can}; }
        template<typename T> static inline void get_stack_size_can(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_size_can}; }
        template<typename T> static inline auto get_stack_size_analog(T* obj) { return Property<const uint32_t>{&obj->stack_size_analog}; }
        template<typename T> static inline void get_stack_size_analog(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_size_analog}; }
        template<typename T> static inline auto get_prio_axis(T* obj) { return Property<const int32_t>{&obj->prio_axis}; }
        template<typename T> static inline void get_prio_axis(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->prio_axis}; }
        template<typename T> static inline auto get_prio_usb(T* obj) { return Property<const int32_t>{&obj->prio_usb}; }
        template<typename T> static inline void get_prio_usb(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->prio_usb}; }
        template<typename T> static inline auto get_prio_uart(T* obj) { return Property<const int32_t>{&obj->prio_uart}; }
        template<typename T> static inline void get_prio_uart(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->prio_uart}; }
        template<typename T> static inline auto get_prio_startup(T* obj) { return Property<const int32_t>{&obj->prio_startup}; }
        template<typename T> static inline void get_prio_startup(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->prio_startup}; }
        template<typename T> static inline auto get_prio_can(T* obj) { return Property<const int32_t>{&obj->prio_can}; }
        template<typename T> static inline void get_prio_can(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->prio_can}; }
        template<typename T> static inline auto get_prio_analog(T* obj) { return Property<const int32_t>{&obj->prio_analog}; }
        template<typename T> static inline void get_prio_analog(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->prio_analog}; }
        template<typename T> static inline auto get_usb(T* obj) { return &obj->usb; }
        template<typename T> static inline auto get_i2c(T* obj) { return &obj->i2c; }
    };
    enum Error {
        ERROR_NONE                       = 0x00000000,
        ERROR_CONTROL_ITERATION_MISSED   = 0x00000001,
        ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
        ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
        ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00000008,
        ERROR_DC_BUS_OVER_CURRENT        = 0x00000010,
        ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000020,
        ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00000040,
        ERROR_INVALID_BRAKE_RESISTANCE   = 0x00000080,
    };
    enum GpioMode {
        GPIO_MODE_DIGITAL                = 0,
        GPIO_MODE_DIGITAL_PULL_UP        = 1,
        GPIO_MODE_DIGITAL_PULL_DOWN      = 2,
        GPIO_MODE_ANALOG_IN              = 3,
        GPIO_MODE_UART_A                 = 4,
        GPIO_MODE_UART_B                 = 5,
        GPIO_MODE_UART_C                 = 6,
        GPIO_MODE_CAN_A                  = 7,
        GPIO_MODE_I2C_A                  = 8,
        GPIO_MODE_SPI_A                  = 9,
        GPIO_MODE_PWM                    = 10,
        GPIO_MODE_ENC0                   = 11,
        GPIO_MODE_ENC1                   = 12,
        GPIO_MODE_ENC2                   = 13,
        GPIO_MODE_MECH_BRAKE             = 14,
        GPIO_MODE_STATUS                 = 15,
    };
    enum StreamProtocolType {
        STREAM_PROTOCOL_TYPE_FIBRE       = 0,
        STREAM_PROTOCOL_TYPE_ASCII       = 1,
        STREAM_PROTOCOL_TYPE_STDOUT      = 2,
        STREAM_PROTOCOL_TYPE_ASCII_AND_STDOUT = 3,
    };
    template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::Error>{&obj->error_}; }
    template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::Error>{&obj->error_}; }
    template<typename T> static inline auto get_vbus_voltage(T* obj) { return Property<const float>{&obj->vbus_voltage_}; }
    template<typename T> static inline void get_vbus_voltage(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->vbus_voltage_}; }
    template<typename T> static inline auto get_ibus(T* obj) { return Property<const float>{&obj->ibus_}; }
    template<typename T> static inline void get_ibus(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->ibus_}; }
    template<typename T> static inline auto get_ibus_report_filter_k(T* obj) { return Property<float>{&obj->ibus_report_filter_k_}; }
    template<typename T> static inline void get_ibus_report_filter_k(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ibus_report_filter_k_}; }
    template<typename T> static inline auto get_serial_number(T* obj) { return Property<const uint64_t>{&obj->serial_number_}; }
    template<typename T> static inline void get_serial_number(T* obj, void* ptr) { new (ptr) Property<const uint64_t>{&obj->serial_number_}; }
    template<typename T> static inline auto get_hw_version_major(T* obj) { return Property<const uint8_t>{&obj->hw_version_major_}; }
    template<typename T> static inline void get_hw_version_major(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hw_version_major_}; }
    template<typename T> static inline auto get_hw_version_minor(T* obj) { return Property<const uint8_t>{&obj->hw_version_minor_}; }
    template<typename T> static inline void get_hw_version_minor(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hw_version_minor_}; }
    template<typename T> static inline auto get_hw_version_variant(T* obj) { return Property<const uint8_t>{&obj->hw_version_variant_}; }
    template<typename T> static inline void get_hw_version_variant(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hw_version_variant_}; }
    template<typename T> static inline auto get_fw_version_major(T* obj) { return Property<const uint8_t>{&obj->fw_version_major_}; }
    template<typename T> static inline void get_fw_version_major(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_major_}; }
    template<typename T> static inline auto get_fw_version_minor(T* obj) { return Property<const uint8_t>{&obj->fw_version_minor_}; }
    template<typename T> static inline void get_fw_version_minor(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_minor_}; }
    template<typename T> static inline auto get_fw_version_revision(T* obj) { return Property<const uint8_t>{&obj->fw_version_revision_}; }
    template<typename T> static inline void get_fw_version_revision(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_revision_}; }
    template<typename T> static inline auto get_fw_version_unreleased(T* obj) { return Property<const uint8_t>{&obj->fw_version_unreleased_}; }
    template<typename T> static inline void get_fw_version_unreleased(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_unreleased_}; }
    template<typename T> static inline auto get_brake_resistor_armed(T* obj) { return Property<const bool>{&obj->brake_resistor_armed_}; }
    template<typename T> static inline void get_brake_resistor_armed(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->brake_resistor_armed_}; }
    template<typename T> static inline auto get_brake_resistor_saturated(T* obj) { return Property<const bool>{&obj->brake_resistor_saturated_}; }
    template<typename T> static inline void get_brake_resistor_saturated(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->brake_resistor_saturated_}; }
    template<typename T> static inline auto get_brake_resistor_current(T* obj) { return Property<const float>{&obj->brake_resistor_current_}; }
    template<typename T> static inline void get_brake_resistor_current(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->brake_resistor_current_}; }
    template<typename T> static inline auto get_n_evt_sampling(T* obj) { return Property<const uint32_t>{&obj->n_evt_sampling_}; }
    template<typename T> static inline void get_n_evt_sampling(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->n_evt_sampling_}; }
    template<typename T> static inline auto get_n_evt_control_loop(T* obj) { return Property<const uint32_t>{&obj->n_evt_control_loop_}; }
    template<typename T> static inline void get_n_evt_control_loop(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->n_evt_control_loop_}; }
    template<typename T> static inline auto get_task_timers_armed(T* obj) { return Property<bool>{&obj->task_timers_armed_}; }
    template<typename T> static inline void get_task_timers_armed(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->task_timers_armed_}; }
    template<typename T> static inline auto get_task_times(T* obj) { return &obj->task_times_; }
    template<typename T> static inline auto get_system_stats(T* obj) { return &obj->system_stats_; }
    template<typename T> static inline auto get_user_config_loaded(T* obj) { return Property<const uint32_t>{&obj->user_config_loaded_}; }
    template<typename T> static inline void get_user_config_loaded(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->user_config_loaded_}; }
    template<typename T> static inline auto get_misconfigured(T* obj) { return Property<const bool>{&obj->misconfigured_}; }
    template<typename T> static inline void get_misconfigured(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->misconfigured_}; }
    template<typename T> static inline auto get_oscilloscope(T* obj) { return &obj->oscilloscope_; }
    template<typename T> static inline auto get_can(T* obj) { return &obj->can_; }
    template<typename T> static inline auto get_test_property(T* obj) { return Property<uint32_t>{&obj->test_property_}; }
    template<typename T> static inline void get_test_property(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->test_property_}; }
    template<typename T> static inline auto get_otp_valid(T* obj) { return Property<const bool>{&obj->otp_valid_}; }
    template<typename T> static inline void get_otp_valid(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->otp_valid_}; }
    virtual int32_t test_function(int32_t delta) = 0;
    virtual float get_adc_voltage(uint32_t gpio) = 0;
    virtual bool save_configuration() = 0;
    virtual void erase_configuration() = 0;
    virtual void reboot() = 0;
    virtual void enter_dfu_mode() = 0;
    virtual uint32_t get_interrupt_status(int32_t irqn) = 0;
    virtual uint32_t get_dma_status(uint8_t stream_num) = 0;
    virtual uint32_t get_gpio_states() = 0;
    virtual uint64_t get_drv_fault() = 0;
    virtual void clear_errors() = 0;
    int32_t test_function_in_delta_; // for internal use by Fibre
    template<typename T> static auto get_test_function_in_delta_(T* obj) { return Property<int32_t>{&obj->test_function_in_delta_}; }
    template<typename T> static void get_test_function_in_delta_(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->test_function_in_delta_}; }
    int32_t test_function_out_cnt_; // for internal use by Fibre
    template<typename T> static auto get_test_function_out_cnt_(T* obj) { return Property<const int32_t>{&obj->test_function_out_cnt_}; }
    template<typename T> static void get_test_function_out_cnt_(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->test_function_out_cnt_}; }
    uint32_t get_adc_voltage_in_gpio_; // for internal use by Fibre
    template<typename T> static auto get_get_adc_voltage_in_gpio_(T* obj) { return Property<uint32_t>{&obj->get_adc_voltage_in_gpio_}; }
    template<typename T> static void get_get_adc_voltage_in_gpio_(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->get_adc_voltage_in_gpio_}; }
    float get_adc_voltage_out_voltage_; // for internal use by Fibre
    template<typename T> static auto get_get_adc_voltage_out_voltage_(T* obj) { return Property<const float>{&obj->get_adc_voltage_out_voltage_}; }
    template<typename T> static void get_get_adc_voltage_out_voltage_(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->get_adc_voltage_out_voltage_}; }
    bool save_configuration_out_success_; // for internal use by Fibre
    template<typename T> static auto get_save_configuration_out_success_(T* obj) { return Property<const bool>{&obj->save_configuration_out_success_}; }
    template<typename T> static void get_save_configuration_out_success_(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->save_configuration_out_success_}; }
    int32_t get_interrupt_status_in_irqn_; // for internal use by Fibre
    template<typename T> static auto get_get_interrupt_status_in_irqn_(T* obj) { return Property<int32_t>{&obj->get_interrupt_status_in_irqn_}; }
    template<typename T> static void get_get_interrupt_status_in_irqn_(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->get_interrupt_status_in_irqn_}; }
    uint32_t get_interrupt_status_out_status_; // for internal use by Fibre
    template<typename T> static auto get_get_interrupt_status_out_status_(T* obj) { return Property<const uint32_t>{&obj->get_interrupt_status_out_status_}; }
    template<typename T> static void get_get_interrupt_status_out_status_(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->get_interrupt_status_out_status_}; }
    uint8_t get_dma_status_in_stream_num_; // for internal use by Fibre
    template<typename T> static auto get_get_dma_status_in_stream_num_(T* obj) { return Property<uint8_t>{&obj->get_dma_status_in_stream_num_}; }
    template<typename T> static void get_get_dma_status_in_stream_num_(T* obj, void* ptr) { new (ptr) Property<uint8_t>{&obj->get_dma_status_in_stream_num_}; }
    uint32_t get_dma_status_out_status_; // for internal use by Fibre
    template<typename T> static auto get_get_dma_status_out_status_(T* obj) { return Property<const uint32_t>{&obj->get_dma_status_out_status_}; }
    template<typename T> static void get_get_dma_status_out_status_(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->get_dma_status_out_status_}; }
    uint32_t get_gpio_states_out_status_; // for internal use by Fibre
    template<typename T> static auto get_get_gpio_states_out_status_(T* obj) { return Property<const uint32_t>{&obj->get_gpio_states_out_status_}; }
    template<typename T> static void get_get_gpio_states_out_status_(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->get_gpio_states_out_status_}; }
    uint64_t get_drv_fault_out_drv_fault_; // for internal use by Fibre
    template<typename T> static auto get_get_drv_fault_out_drv_fault_(T* obj) { return Property<const uint64_t>{&obj->get_drv_fault_out_drv_fault_}; }
    template<typename T> static void get_get_drv_fault_out_drv_fault_(T* obj, void* ptr) { new (ptr) Property<const uint64_t>{&obj->get_drv_fault_out_drv_fault_}; }
};


class ODrive3Intf : public ODriveIntf {
public:
    class ConfigIntf : public ODriveIntf::ConfigIntf {
    public:
        template<typename T> static inline auto get_gpio1_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[1]}; }
        template<typename T> static inline void get_gpio1_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[1]}; }
        template<typename T> static inline auto get_gpio2_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[2]}; }
        template<typename T> static inline void get_gpio2_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[2]}; }
        template<typename T> static inline auto get_gpio3_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[3]}; }
        template<typename T> static inline void get_gpio3_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[3]}; }
        template<typename T> static inline auto get_gpio4_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[4]}; }
        template<typename T> static inline void get_gpio4_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[4]}; }
        template<typename T> static inline auto get_gpio5_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[5]}; }
        template<typename T> static inline void get_gpio5_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[5]}; }
        template<typename T> static inline auto get_gpio6_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[6]}; }
        template<typename T> static inline void get_gpio6_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[6]}; }
        template<typename T> static inline auto get_gpio7_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[7]}; }
        template<typename T> static inline void get_gpio7_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[7]}; }
        template<typename T> static inline auto get_gpio8_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[8]}; }
        template<typename T> static inline void get_gpio8_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[8]}; }
        template<typename T> static inline auto get_gpio9_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[9]}; }
        template<typename T> static inline void get_gpio9_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[9]}; }
        template<typename T> static inline auto get_gpio10_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[10]}; }
        template<typename T> static inline void get_gpio10_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[10]}; }
        template<typename T> static inline auto get_gpio11_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[11]}; }
        template<typename T> static inline void get_gpio11_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[11]}; }
        template<typename T> static inline auto get_gpio12_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[12]}; }
        template<typename T> static inline void get_gpio12_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[12]}; }
        template<typename T> static inline auto get_gpio13_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[13]}; }
        template<typename T> static inline void get_gpio13_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[13]}; }
        template<typename T> static inline auto get_gpio14_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[14]}; }
        template<typename T> static inline void get_gpio14_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[14]}; }
        template<typename T> static inline auto get_gpio15_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[15]}; }
        template<typename T> static inline void get_gpio15_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[15]}; }
        template<typename T> static inline auto get_gpio16_mode(T* obj) { return Property<ODriveIntf::GpioMode>{&obj->gpio_modes[16]}; }
        template<typename T> static inline void get_gpio16_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::GpioMode>{&obj->gpio_modes[16]}; }
        template<typename T> static inline auto get_gpio1_pwm_mapping(T* obj) { return &obj->pwm_mappings[0]; }
        template<typename T> static inline auto get_gpio2_pwm_mapping(T* obj) { return &obj->pwm_mappings[1]; }
        template<typename T> static inline auto get_gpio3_pwm_mapping(T* obj) { return &obj->pwm_mappings[2]; }
        template<typename T> static inline auto get_gpio4_pwm_mapping(T* obj) { return &obj->pwm_mappings[3]; }
    };
    template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    template<typename T> static inline auto get_axis0(T* obj) { return &obj->get_axis(0); }
    template<typename T> static inline auto get_axis1(T* obj) { return &obj->get_axis(1); }
};

// this is technically not thread-safe but practically it might be
inline ODriveIntf::CanIntf::Protocol operator | (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIntf::Protocol b) { return static_cast<ODriveIntf::CanIntf::Protocol>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(a) | static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(b)); }
inline ODriveIntf::CanIntf::Protocol operator & (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIntf::Protocol b) { return static_cast<ODriveIntf::CanIntf::Protocol>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(a) & static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(b)); }
inline ODriveIntf::CanIntf::Protocol operator ^ (ODriveIntf::CanIntf::Protocol a, ODriveIntf::CanIntf::Protocol b) { return static_cast<ODriveIntf::CanIntf::Protocol>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(b)); }
inline ODriveIntf::CanIntf::Protocol& operator |= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::CanIntf::Protocol b) { return reinterpret_cast<ODriveIntf::CanIntf::Protocol&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(b)); }
inline ODriveIntf::CanIntf::Protocol& operator &= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::CanIntf::Protocol b) { return reinterpret_cast<ODriveIntf::CanIntf::Protocol&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(b)); }
inline ODriveIntf::CanIntf::Protocol& operator ^= (ODriveIntf::CanIntf::Protocol &a, ODriveIntf::CanIntf::Protocol b) { return reinterpret_cast<ODriveIntf::CanIntf::Protocol&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(b)); }
inline ODriveIntf::CanIntf::Protocol operator ~ (ODriveIntf::CanIntf::Protocol a) { return static_cast<ODriveIntf::CanIntf::Protocol>(~static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Protocol>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::Error operator | (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast<ODriveIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); }
inline ODriveIntf::Error operator & (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast<ODriveIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); }
inline ODriveIntf::Error operator ^ (ODriveIntf::Error a, ODriveIntf::Error b) { return static_cast<ODriveIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); }
inline ODriveIntf::Error& operator |= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterpret_cast<ODriveIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); }
inline ODriveIntf::Error& operator &= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterpret_cast<ODriveIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); }
inline ODriveIntf::Error& operator ^= (ODriveIntf::Error &a, ODriveIntf::Error b) { return reinterpret_cast<ODriveIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); }
inline ODriveIntf::Error operator ~ (ODriveIntf::Error a) { return static_cast<ODriveIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::CanIntf::Error operator | (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Error b) { return static_cast<ODriveIntf::CanIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error operator & (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Error b) { return static_cast<ODriveIntf::CanIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error operator ^ (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Error b) { return static_cast<ODriveIntf::CanIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error& operator |= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf::Error b) { return reinterpret_cast<ODriveIntf::CanIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error& operator &= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf::Error b) { return reinterpret_cast<ODriveIntf::CanIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error& operator ^= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf::Error b) { return reinterpret_cast<ODriveIntf::CanIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error operator ~ (ODriveIntf::CanIntf::Error a) { return static_cast<ODriveIntf::CanIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::AxisIntf::Error operator | (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) { return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error operator & (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) { return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error operator ^ (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) { return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error& operator |= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) { return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error& operator &= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) { return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error& operator ^= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) { return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error operator ~ (ODriveIntf::AxisIntf::Error a) { return static_cast<ODriveIntf::AxisIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::MotorIntf::Error operator | (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) { return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error operator & (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) { return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error operator ^ (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) { return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error& operator |= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) { return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error& operator &= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) { return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error& operator ^= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) { return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error operator ~ (ODriveIntf::MotorIntf::Error a) { return static_cast<ODriveIntf::MotorIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::ControllerIntf::Error operator | (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) { return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error operator & (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) { return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error operator ^ (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) { return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error& operator |= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) { return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error& operator &= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) { return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error& operator ^= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) { return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error operator ~ (ODriveIntf::ControllerIntf::Error a) { return static_cast<ODriveIntf::ControllerIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::EncoderIntf::Error operator | (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) { return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error operator & (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) { return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error operator ^ (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) { return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error& operator |= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) { return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error& operator &= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) { return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error& operator ^= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) { return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error operator ~ (ODriveIntf::EncoderIntf::Error a) { return static_cast<ODriveIntf::EncoderIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::SensorlessEstimatorIntf::Error operator | (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error operator & (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error operator ^ (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error& operator |= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error& operator &= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error& operator ^= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error operator ~ (ODriveIntf::SensorlessEstimatorIntf::Error a) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a)); }



#pragma GCC pop_options

#endif // __FIBRE_INTERFACES_HPP