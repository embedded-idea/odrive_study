/*
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains support functions for the ODrive ASCII protocol.
 *
 * TODO: might generalize this as an approach to runtime introspection.
 */

#include <fibre/introspection.hpp>

#pragma GCC push_options
#pragma GCC optimize ("s")


template<typename T>
struct ODriveTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::get_vbus_voltage(std::declval<T*>()))*)(&res) = ODriveIntf::get_vbus_voltage(ptr); break;
            case 2: *(decltype(ODriveIntf::get_ibus(std::declval<T*>()))*)(&res) = ODriveIntf::get_ibus(ptr); break;
            case 3: *(decltype(ODriveIntf::get_ibus_report_filter_k(std::declval<T*>()))*)(&res) = ODriveIntf::get_ibus_report_filter_k(ptr); break;
            case 4: *(decltype(ODriveIntf::get_serial_number(std::declval<T*>()))*)(&res) = ODriveIntf::get_serial_number(ptr); break;
            case 5: *(decltype(ODriveIntf::get_hw_version_major(std::declval<T*>()))*)(&res) = ODriveIntf::get_hw_version_major(ptr); break;
            case 6: *(decltype(ODriveIntf::get_hw_version_minor(std::declval<T*>()))*)(&res) = ODriveIntf::get_hw_version_minor(ptr); break;
            case 7: *(decltype(ODriveIntf::get_hw_version_variant(std::declval<T*>()))*)(&res) = ODriveIntf::get_hw_version_variant(ptr); break;
            case 8: *(decltype(ODriveIntf::get_fw_version_major(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_major(ptr); break;
            case 9: *(decltype(ODriveIntf::get_fw_version_minor(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_minor(ptr); break;
            case 10: *(decltype(ODriveIntf::get_fw_version_revision(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_revision(ptr); break;
            case 11: *(decltype(ODriveIntf::get_fw_version_unreleased(std::declval<T*>()))*)(&res) = ODriveIntf::get_fw_version_unreleased(ptr); break;
            case 12: *(decltype(ODriveIntf::get_brake_resistor_armed(std::declval<T*>()))*)(&res) = ODriveIntf::get_brake_resistor_armed(ptr); break;
            case 13: *(decltype(ODriveIntf::get_brake_resistor_saturated(std::declval<T*>()))*)(&res) = ODriveIntf::get_brake_resistor_saturated(ptr); break;
            case 14: *(decltype(ODriveIntf::get_brake_resistor_current(std::declval<T*>()))*)(&res) = ODriveIntf::get_brake_resistor_current(ptr); break;
            case 15: *(decltype(ODriveIntf::get_n_evt_sampling(std::declval<T*>()))*)(&res) = ODriveIntf::get_n_evt_sampling(ptr); break;
            case 16: *(decltype(ODriveIntf::get_n_evt_control_loop(std::declval<T*>()))*)(&res) = ODriveIntf::get_n_evt_control_loop(ptr); break;
            case 17: *(decltype(ODriveIntf::get_task_timers_armed(std::declval<T*>()))*)(&res) = ODriveIntf::get_task_timers_armed(ptr); break;
            case 18: *(decltype(ODriveIntf::get_task_times(std::declval<T*>()))*)(&res) = ODriveIntf::get_task_times(ptr); break;
            case 19: *(decltype(ODriveIntf::get_system_stats(std::declval<T*>()))*)(&res) = ODriveIntf::get_system_stats(ptr); break;
            case 20: *(decltype(ODriveIntf::get_user_config_loaded(std::declval<T*>()))*)(&res) = ODriveIntf::get_user_config_loaded(ptr); break;
            case 21: *(decltype(ODriveIntf::get_misconfigured(std::declval<T*>()))*)(&res) = ODriveIntf::get_misconfigured(ptr); break;
            case 22: *(decltype(ODriveIntf::get_oscilloscope(std::declval<T*>()))*)(&res) = ODriveIntf::get_oscilloscope(ptr); break;
            case 23: *(decltype(ODriveIntf::get_can(std::declval<T*>()))*)(&res) = ODriveIntf::get_can(ptr); break;
            case 24: *(decltype(ODriveIntf::get_test_property(std::declval<T*>()))*)(&res) = ODriveIntf::get_test_property(ptr); break;
            case 25: *(decltype(ODriveIntf::get_otp_valid(std::declval<T*>()))*)(&res) = ODriveIntf::get_otp_valid(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ConfigIntf::get_enable_uart_a(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_uart_a(ptr); break;
            case 1: *(decltype(ODriveIntf::ConfigIntf::get_enable_uart_b(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_uart_b(ptr); break;
            case 2: *(decltype(ODriveIntf::ConfigIntf::get_enable_uart_c(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_uart_c(ptr); break;
            case 3: *(decltype(ODriveIntf::ConfigIntf::get_uart_a_baudrate(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_uart_a_baudrate(ptr); break;
            case 4: *(decltype(ODriveIntf::ConfigIntf::get_uart_b_baudrate(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_uart_b_baudrate(ptr); break;
            case 5: *(decltype(ODriveIntf::ConfigIntf::get_uart_c_baudrate(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_uart_c_baudrate(ptr); break;
            case 6: *(decltype(ODriveIntf::ConfigIntf::get_enable_can_a(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_can_a(ptr); break;
            case 7: *(decltype(ODriveIntf::ConfigIntf::get_enable_i2c_a(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_i2c_a(ptr); break;
            case 8: *(decltype(ODriveIntf::ConfigIntf::get_usb_cdc_protocol(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_usb_cdc_protocol(ptr); break;
            case 9: *(decltype(ODriveIntf::ConfigIntf::get_uart0_protocol(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_uart0_protocol(ptr); break;
            case 10: *(decltype(ODriveIntf::ConfigIntf::get_uart1_protocol(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_uart1_protocol(ptr); break;
            case 11: *(decltype(ODriveIntf::ConfigIntf::get_uart2_protocol(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_uart2_protocol(ptr); break;
            case 12: *(decltype(ODriveIntf::ConfigIntf::get_max_regen_current(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_max_regen_current(ptr); break;
            case 13: *(decltype(ODriveIntf::ConfigIntf::get_brake_resistance(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_brake_resistance(ptr); break;
            case 14: *(decltype(ODriveIntf::ConfigIntf::get_enable_brake_resistor(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_brake_resistor(ptr); break;
            case 15: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_undervoltage_trip_level(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_undervoltage_trip_level(ptr); break;
            case 16: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_trip_level(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_trip_level(ptr); break;
            case 17: *(decltype(ODriveIntf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(ptr); break;
            case 18: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(ptr); break;
            case 19: *(decltype(ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(ptr); break;
            case 20: *(decltype(ODriveIntf::ConfigIntf::get_dc_max_positive_current(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_max_positive_current(ptr); break;
            case 21: *(decltype(ODriveIntf::ConfigIntf::get_dc_max_negative_current(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_dc_max_negative_current(ptr); break;
            case 22: *(decltype(ODriveIntf::ConfigIntf::get_error_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_error_gpio_pin(ptr); break;
            case 23: *(decltype(ODriveIntf::ConfigIntf::get_gpio3_analog_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio3_analog_mapping(ptr); break;
            case 24: *(decltype(ODriveIntf::ConfigIntf::get_gpio4_analog_mapping(std::declval<T*>()))*)(&res) = ODriveIntf::ConfigIntf::get_gpio4_analog_mapping(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveCanTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveCanTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::CanIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::CanIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEndpointTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEndpointTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EndpointIntf::get_endpoint(std::declval<T*>()))*)(&res) = ODriveIntf::EndpointIntf::get_endpoint(ptr); break;
            case 1: *(decltype(ODriveIntf::EndpointIntf::get_min(std::declval<T*>()))*)(&res) = ODriveIntf::EndpointIntf::get_min(ptr); break;
            case 2: *(decltype(ODriveIntf::EndpointIntf::get_max(std::declval<T*>()))*)(&res) = ODriveIntf::EndpointIntf::get_max(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::get_step_dir_active(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_step_dir_active(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::get_last_drv_fault(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_last_drv_fault(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::get_steps(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_steps(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::get_current_state(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_current_state(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::get_requested_state(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_requested_state(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::get_is_homed(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_is_homed(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_config(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::get_motor(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_motor(ptr); break;
            case 9: *(decltype(ODriveIntf::AxisIntf::get_controller(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_controller(ptr); break;
            case 10: *(decltype(ODriveIntf::AxisIntf::get_encoder(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_encoder(ptr); break;
            case 11: *(decltype(ODriveIntf::AxisIntf::get_acim_estimator(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_acim_estimator(ptr); break;
            case 12: *(decltype(ODriveIntf::AxisIntf::get_sensorless_estimator(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_sensorless_estimator(ptr); break;
            case 13: *(decltype(ODriveIntf::AxisIntf::get_trap_traj(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_trap_traj(ptr); break;
            case 14: *(decltype(ODriveIntf::AxisIntf::get_min_endstop(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_min_endstop(ptr); break;
            case 15: *(decltype(ODriveIntf::AxisIntf::get_max_endstop(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_max_endstop(ptr); break;
            case 16: *(decltype(ODriveIntf::AxisIntf::get_mechanical_brake(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_mechanical_brake(ptr); break;
            case 17: *(decltype(ODriveIntf::AxisIntf::get_task_times(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::get_task_times(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisLockinConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisLockinConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_current(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_current(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_time(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_time(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_distance(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_accel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_accel(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_vel(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_distance(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_vel(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_distance(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_enc_idx(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_enc_idx(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisCanConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisCanConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_node_id(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_node_id(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_is_extended(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_is_extended(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_heartbeat_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_heartbeat_rate_ms(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_rate_ms(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_motor_error_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_motor_error_rate_ms(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_error_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_error_rate_ms(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_controller_error_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_controller_error_rate_ms(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_sensorless_error_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_sensorless_error_rate_ms(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_count_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_count_rate_ms(ptr); break;
            case 9: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_iq_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_iq_rate_ms(ptr); break;
            case 10: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_sensorless_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_sensorless_rate_ms(ptr); break;
            case 11: *(decltype(ODriveIntf::AxisIntf::CanConfigIntf::get_bus_vi_rate_ms(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::CanConfigIntf::get_bus_vi_rate_ms(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveThermistorCurrentLimiterTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveThermistorCurrentLimiterTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
        }
        return res;
    }
};

template<typename T>
struct ODriveOnboardThermistorCurrentLimiterTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveOnboardThermistorCurrentLimiterTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::OnboardThermistorCurrentLimiterIntf::get_temperature(std::declval<T*>()))*)(&res) = ODriveIntf::OnboardThermistorCurrentLimiterIntf::get_temperature(ptr); break;
            case 1: *(decltype(ODriveIntf::OnboardThermistorCurrentLimiterIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::OnboardThermistorCurrentLimiterIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveOffboardThermistorCurrentLimiterTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveOffboardThermistorCurrentLimiterTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::get_temperature(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::get_temperature(ptr); break;
            case 1: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::get_last_error_time(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_last_error_time(ptr); break;
            case 1: *(decltype(ODriveIntf::MotorIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_error(ptr); break;
            case 2: *(decltype(ODriveIntf::MotorIntf::get_is_armed(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_is_armed(ptr); break;
            case 3: *(decltype(ODriveIntf::MotorIntf::get_is_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_is_calibrated(ptr); break;
            case 4: *(decltype(ODriveIntf::MotorIntf::get_current_meas_phA(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_current_meas_phA(ptr); break;
            case 5: *(decltype(ODriveIntf::MotorIntf::get_current_meas_phB(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_current_meas_phB(ptr); break;
            case 6: *(decltype(ODriveIntf::MotorIntf::get_current_meas_phC(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_current_meas_phC(ptr); break;
            case 7: *(decltype(ODriveIntf::MotorIntf::get_DC_calib_phA(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_DC_calib_phA(ptr); break;
            case 8: *(decltype(ODriveIntf::MotorIntf::get_DC_calib_phB(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_DC_calib_phB(ptr); break;
            case 9: *(decltype(ODriveIntf::MotorIntf::get_DC_calib_phC(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_DC_calib_phC(ptr); break;
            case 10: *(decltype(ODriveIntf::MotorIntf::get_I_bus(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_I_bus(ptr); break;
            case 11: *(decltype(ODriveIntf::MotorIntf::get_phase_current_rev_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_phase_current_rev_gain(ptr); break;
            case 12: *(decltype(ODriveIntf::MotorIntf::get_effective_current_lim(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_effective_current_lim(ptr); break;
            case 13: *(decltype(ODriveIntf::MotorIntf::get_max_allowed_current(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_max_allowed_current(ptr); break;
            case 14: *(decltype(ODriveIntf::MotorIntf::get_max_dc_calib(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_max_dc_calib(ptr); break;
            case 15: *(decltype(ODriveIntf::MotorIntf::get_fet_thermistor(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_fet_thermistor(ptr); break;
            case 16: *(decltype(ODriveIntf::MotorIntf::get_motor_thermistor(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_motor_thermistor(ptr); break;
            case 17: *(decltype(ODriveIntf::MotorIntf::get_current_control(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_current_control(ptr); break;
            case 18: *(decltype(ODriveIntf::MotorIntf::get_n_evt_current_measurement(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_n_evt_current_measurement(ptr); break;
            case 19: *(decltype(ODriveIntf::MotorIntf::get_n_evt_pwm_update(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_n_evt_pwm_update(ptr); break;
            case 20: *(decltype(ODriveIntf::MotorIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveOscilloscopeTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveOscilloscopeTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::OscilloscopeIntf::get_size(std::declval<T*>()))*)(&res) = ODriveIntf::OscilloscopeIntf::get_size(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAcimEstimatorTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAcimEstimatorTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AcimEstimatorIntf::get_rotor_flux(std::declval<T*>()))*)(&res) = ODriveIntf::AcimEstimatorIntf::get_rotor_flux(ptr); break;
            case 1: *(decltype(ODriveIntf::AcimEstimatorIntf::get_slip_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AcimEstimatorIntf::get_slip_vel(ptr); break;
            case 2: *(decltype(ODriveIntf::AcimEstimatorIntf::get_phase_offset(std::declval<T*>()))*)(&res) = ODriveIntf::AcimEstimatorIntf::get_phase_offset(ptr); break;
            case 3: *(decltype(ODriveIntf::AcimEstimatorIntf::get_stator_phase_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AcimEstimatorIntf::get_stator_phase_vel(ptr); break;
            case 4: *(decltype(ODriveIntf::AcimEstimatorIntf::get_stator_phase(std::declval<T*>()))*)(&res) = ODriveIntf::AcimEstimatorIntf::get_stator_phase(ptr); break;
            case 5: *(decltype(ODriveIntf::AcimEstimatorIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::AcimEstimatorIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveControllerTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveControllerTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ControllerIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::ControllerIntf::get_last_error_time(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_last_error_time(ptr); break;
            case 2: *(decltype(ODriveIntf::ControllerIntf::get_input_pos(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_input_pos(ptr); break;
            case 3: *(decltype(ODriveIntf::ControllerIntf::get_input_vel(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_input_vel(ptr); break;
            case 4: *(decltype(ODriveIntf::ControllerIntf::get_input_torque(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_input_torque(ptr); break;
            case 5: *(decltype(ODriveIntf::ControllerIntf::get_pos_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_pos_setpoint(ptr); break;
            case 6: *(decltype(ODriveIntf::ControllerIntf::get_vel_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_vel_setpoint(ptr); break;
            case 7: *(decltype(ODriveIntf::ControllerIntf::get_torque_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_torque_setpoint(ptr); break;
            case 8: *(decltype(ODriveIntf::ControllerIntf::get_trajectory_done(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_trajectory_done(ptr); break;
            case 9: *(decltype(ODriveIntf::ControllerIntf::get_vel_integrator_torque(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_vel_integrator_torque(ptr); break;
            case 10: *(decltype(ODriveIntf::ControllerIntf::get_anticogging_valid(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_anticogging_valid(ptr); break;
            case 11: *(decltype(ODriveIntf::ControllerIntf::get_autotuning_phase(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_autotuning_phase(ptr); break;
            case 12: *(decltype(ODriveIntf::ControllerIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_config(ptr); break;
            case 13: *(decltype(ODriveIntf::ControllerIntf::get_autotuning(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_autotuning(ptr); break;
            case 14: *(decltype(ODriveIntf::ControllerIntf::get_mechanical_power(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_mechanical_power(ptr); break;
            case 15: *(decltype(ODriveIntf::ControllerIntf::get_electrical_power(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::get_electrical_power(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEncoderTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEncoderTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EncoderIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::EncoderIntf::get_is_ready(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_is_ready(ptr); break;
            case 2: *(decltype(ODriveIntf::EncoderIntf::get_index_found(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_index_found(ptr); break;
            case 3: *(decltype(ODriveIntf::EncoderIntf::get_shadow_count(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_shadow_count(ptr); break;
            case 4: *(decltype(ODriveIntf::EncoderIntf::get_count_in_cpr(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_count_in_cpr(ptr); break;
            case 5: *(decltype(ODriveIntf::EncoderIntf::get_interpolation(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_interpolation(ptr); break;
            case 6: *(decltype(ODriveIntf::EncoderIntf::get_phase(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_phase(ptr); break;
            case 7: *(decltype(ODriveIntf::EncoderIntf::get_pos_estimate(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_estimate(ptr); break;
            case 8: *(decltype(ODriveIntf::EncoderIntf::get_pos_estimate_counts(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_estimate_counts(ptr); break;
            case 9: *(decltype(ODriveIntf::EncoderIntf::get_pos_circular(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_circular(ptr); break;
            case 10: *(decltype(ODriveIntf::EncoderIntf::get_pos_cpr_counts(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_cpr_counts(ptr); break;
            case 11: *(decltype(ODriveIntf::EncoderIntf::get_delta_pos_cpr_counts(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_delta_pos_cpr_counts(ptr); break;
            case 12: *(decltype(ODriveIntf::EncoderIntf::get_hall_state(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_hall_state(ptr); break;
            case 13: *(decltype(ODriveIntf::EncoderIntf::get_vel_estimate(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_vel_estimate(ptr); break;
            case 14: *(decltype(ODriveIntf::EncoderIntf::get_vel_estimate_counts(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_vel_estimate_counts(ptr); break;
            case 15: *(decltype(ODriveIntf::EncoderIntf::get_calib_scan_response(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_calib_scan_response(ptr); break;
            case 16: *(decltype(ODriveIntf::EncoderIntf::get_pos_abs(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_pos_abs(ptr); break;
            case 17: *(decltype(ODriveIntf::EncoderIntf::get_spi_error_rate(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_spi_error_rate(ptr); break;
            case 18: *(decltype(ODriveIntf::EncoderIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSensorlessEstimatorTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSensorlessEstimatorTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_error(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_error(ptr); break;
            case 1: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_phase(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_phase(ptr); break;
            case 2: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_pll_pos(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_pll_pos(ptr); break;
            case 3: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_phase_vel(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_phase_vel(ptr); break;
            case 4: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_vel_estimate(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_vel_estimate(ptr); break;
            case 5: *(decltype(ODriveIntf::SensorlessEstimatorIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveTrapezoidalTrajectoryTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTrapezoidalTrajectoryTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEndstopTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEndstopTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EndstopIntf::get_endstop_state(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::get_endstop_state(ptr); break;
            case 1: *(decltype(ODriveIntf::EndstopIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMechanicalBrakeTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMechanicalBrakeTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MechanicalBrakeIntf::get_config(std::declval<T*>()))*)(&res) = ODriveIntf::MechanicalBrakeIntf::get_config(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveTaskTimerTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTaskTimerTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::TaskTimerIntf::get_start_time(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimerIntf::get_start_time(ptr); break;
            case 1: *(decltype(ODriveIntf::TaskTimerIntf::get_end_time(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimerIntf::get_end_time(ptr); break;
            case 2: *(decltype(ODriveIntf::TaskTimerIntf::get_length(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimerIntf::get_length(ptr); break;
            case 3: *(decltype(ODriveIntf::TaskTimerIntf::get_max_length(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimerIntf::get_max_length(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODrive3TypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODrive3TypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODrive3Intf::get_error(std::declval<T*>()))*)(&res) = ODrive3Intf::get_error(ptr); break;
            case 1: *(decltype(ODrive3Intf::get_vbus_voltage(std::declval<T*>()))*)(&res) = ODrive3Intf::get_vbus_voltage(ptr); break;
            case 2: *(decltype(ODrive3Intf::get_ibus(std::declval<T*>()))*)(&res) = ODrive3Intf::get_ibus(ptr); break;
            case 3: *(decltype(ODrive3Intf::get_ibus_report_filter_k(std::declval<T*>()))*)(&res) = ODrive3Intf::get_ibus_report_filter_k(ptr); break;
            case 4: *(decltype(ODrive3Intf::get_serial_number(std::declval<T*>()))*)(&res) = ODrive3Intf::get_serial_number(ptr); break;
            case 5: *(decltype(ODrive3Intf::get_hw_version_major(std::declval<T*>()))*)(&res) = ODrive3Intf::get_hw_version_major(ptr); break;
            case 6: *(decltype(ODrive3Intf::get_hw_version_minor(std::declval<T*>()))*)(&res) = ODrive3Intf::get_hw_version_minor(ptr); break;
            case 7: *(decltype(ODrive3Intf::get_hw_version_variant(std::declval<T*>()))*)(&res) = ODrive3Intf::get_hw_version_variant(ptr); break;
            case 8: *(decltype(ODrive3Intf::get_fw_version_major(std::declval<T*>()))*)(&res) = ODrive3Intf::get_fw_version_major(ptr); break;
            case 9: *(decltype(ODrive3Intf::get_fw_version_minor(std::declval<T*>()))*)(&res) = ODrive3Intf::get_fw_version_minor(ptr); break;
            case 10: *(decltype(ODrive3Intf::get_fw_version_revision(std::declval<T*>()))*)(&res) = ODrive3Intf::get_fw_version_revision(ptr); break;
            case 11: *(decltype(ODrive3Intf::get_fw_version_unreleased(std::declval<T*>()))*)(&res) = ODrive3Intf::get_fw_version_unreleased(ptr); break;
            case 12: *(decltype(ODrive3Intf::get_brake_resistor_armed(std::declval<T*>()))*)(&res) = ODrive3Intf::get_brake_resistor_armed(ptr); break;
            case 13: *(decltype(ODrive3Intf::get_brake_resistor_saturated(std::declval<T*>()))*)(&res) = ODrive3Intf::get_brake_resistor_saturated(ptr); break;
            case 14: *(decltype(ODrive3Intf::get_brake_resistor_current(std::declval<T*>()))*)(&res) = ODrive3Intf::get_brake_resistor_current(ptr); break;
            case 15: *(decltype(ODrive3Intf::get_n_evt_sampling(std::declval<T*>()))*)(&res) = ODrive3Intf::get_n_evt_sampling(ptr); break;
            case 16: *(decltype(ODrive3Intf::get_n_evt_control_loop(std::declval<T*>()))*)(&res) = ODrive3Intf::get_n_evt_control_loop(ptr); break;
            case 17: *(decltype(ODrive3Intf::get_task_timers_armed(std::declval<T*>()))*)(&res) = ODrive3Intf::get_task_timers_armed(ptr); break;
            case 18: *(decltype(ODrive3Intf::get_task_times(std::declval<T*>()))*)(&res) = ODrive3Intf::get_task_times(ptr); break;
            case 19: *(decltype(ODrive3Intf::get_system_stats(std::declval<T*>()))*)(&res) = ODrive3Intf::get_system_stats(ptr); break;
            case 20: *(decltype(ODrive3Intf::get_user_config_loaded(std::declval<T*>()))*)(&res) = ODrive3Intf::get_user_config_loaded(ptr); break;
            case 21: *(decltype(ODrive3Intf::get_misconfigured(std::declval<T*>()))*)(&res) = ODrive3Intf::get_misconfigured(ptr); break;
            case 22: *(decltype(ODrive3Intf::get_oscilloscope(std::declval<T*>()))*)(&res) = ODrive3Intf::get_oscilloscope(ptr); break;
            case 23: *(decltype(ODrive3Intf::get_can(std::declval<T*>()))*)(&res) = ODrive3Intf::get_can(ptr); break;
            case 24: *(decltype(ODrive3Intf::get_test_property(std::declval<T*>()))*)(&res) = ODrive3Intf::get_test_property(ptr); break;
            case 25: *(decltype(ODrive3Intf::get_otp_valid(std::declval<T*>()))*)(&res) = ODrive3Intf::get_otp_valid(ptr); break;
            case 26: *(decltype(ODrive3Intf::get_config(std::declval<T*>()))*)(&res) = ODrive3Intf::get_config(ptr); break;
            case 27: *(decltype(ODrive3Intf::get_axis0(std::declval<T*>()))*)(&res) = ODrive3Intf::get_axis0(ptr); break;
            case 28: *(decltype(ODrive3Intf::get_axis1(std::declval<T*>()))*)(&res) = ODrive3Intf::get_axis1(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveTaskTimesTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTaskTimesTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::TaskTimesIntf::get_sampling(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimesIntf::get_sampling(ptr); break;
            case 1: *(decltype(ODriveIntf::TaskTimesIntf::get_control_loop_misc(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimesIntf::get_control_loop_misc(ptr); break;
            case 2: *(decltype(ODriveIntf::TaskTimesIntf::get_control_loop_checks(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimesIntf::get_control_loop_checks(ptr); break;
            case 3: *(decltype(ODriveIntf::TaskTimesIntf::get_dc_calib_wait(std::declval<T*>()))*)(&res) = ODriveIntf::TaskTimesIntf::get_dc_calib_wait(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSystemStatsTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSystemStatsTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SystemStatsIntf::get_uptime(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_uptime(ptr); break;
            case 1: *(decltype(ODriveIntf::SystemStatsIntf::get_min_heap_space(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_min_heap_space(ptr); break;
            case 2: *(decltype(ODriveIntf::SystemStatsIntf::get_max_stack_usage_axis(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_max_stack_usage_axis(ptr); break;
            case 3: *(decltype(ODriveIntf::SystemStatsIntf::get_max_stack_usage_usb(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_max_stack_usage_usb(ptr); break;
            case 4: *(decltype(ODriveIntf::SystemStatsIntf::get_max_stack_usage_uart(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_max_stack_usage_uart(ptr); break;
            case 5: *(decltype(ODriveIntf::SystemStatsIntf::get_max_stack_usage_can(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_max_stack_usage_can(ptr); break;
            case 6: *(decltype(ODriveIntf::SystemStatsIntf::get_max_stack_usage_startup(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_max_stack_usage_startup(ptr); break;
            case 7: *(decltype(ODriveIntf::SystemStatsIntf::get_max_stack_usage_analog(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_max_stack_usage_analog(ptr); break;
            case 8: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_size_axis(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_size_axis(ptr); break;
            case 9: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_size_usb(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_size_usb(ptr); break;
            case 10: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_size_uart(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_size_uart(ptr); break;
            case 11: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_size_startup(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_size_startup(ptr); break;
            case 12: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_size_can(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_size_can(ptr); break;
            case 13: *(decltype(ODriveIntf::SystemStatsIntf::get_stack_size_analog(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_stack_size_analog(ptr); break;
            case 14: *(decltype(ODriveIntf::SystemStatsIntf::get_prio_axis(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_prio_axis(ptr); break;
            case 15: *(decltype(ODriveIntf::SystemStatsIntf::get_prio_usb(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_prio_usb(ptr); break;
            case 16: *(decltype(ODriveIntf::SystemStatsIntf::get_prio_uart(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_prio_uart(ptr); break;
            case 17: *(decltype(ODriveIntf::SystemStatsIntf::get_prio_startup(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_prio_startup(ptr); break;
            case 18: *(decltype(ODriveIntf::SystemStatsIntf::get_prio_can(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_prio_can(ptr); break;
            case 19: *(decltype(ODriveIntf::SystemStatsIntf::get_prio_analog(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_prio_analog(ptr); break;
            case 20: *(decltype(ODriveIntf::SystemStatsIntf::get_usb(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_usb(ptr); break;
            case 21: *(decltype(ODriveIntf::SystemStatsIntf::get_i2c(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::get_i2c(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSystemStatsUsbTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSystemStatsUsbTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SystemStatsIntf::UsbIntf::get_rx_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::UsbIntf::get_rx_cnt(ptr); break;
            case 1: *(decltype(ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_cnt(ptr); break;
            case 2: *(decltype(ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_overrun_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_overrun_cnt(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSystemStatsI2CTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSystemStatsI2CTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_addr(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_addr(ptr); break;
            case 1: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_addr_match_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_addr_match_cnt(ptr); break;
            case 2: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_rx_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_rx_cnt(ptr); break;
            case 3: *(decltype(ODriveIntf::SystemStatsIntf::I2CIntf::get_error_cnt(std::declval<T*>()))*)(&res) = ODriveIntf::SystemStatsIntf::I2CIntf::get_error_cnt(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveCanConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveCanConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::CanIntf::ConfigIntf::get_baud_rate(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::ConfigIntf::get_baud_rate(ptr); break;
            case 1: *(decltype(ODriveIntf::CanIntf::ConfigIntf::get_protocol(std::declval<T*>()))*)(&res) = ODriveIntf::CanIntf::ConfigIntf::get_protocol(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_motor_calibration(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_motor_calibration(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_index_search(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_index_search(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_offset_calibration(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_offset_calibration(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_closed_loop_control(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_closed_loop_control(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_startup_homing(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_startup_homing(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_enable_step_dir(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_enable_step_dir(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_step_dir_always_on(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_step_dir_always_on(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_enable_sensorless_mode(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_enable_sensorless_mode(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_watchdog_timeout(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_watchdog_timeout(ptr); break;
            case 9: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_enable_watchdog(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_enable_watchdog(ptr); break;
            case 10: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_step_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_step_gpio_pin(ptr); break;
            case 11: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_dir_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_dir_gpio_pin(ptr); break;
            case 12: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_calibration_lockin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_calibration_lockin(ptr); break;
            case 13: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_sensorless_ramp(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_sensorless_ramp(ptr); break;
            case 14: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_general_lockin(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_general_lockin(ptr); break;
            case 15: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::get_can(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::get_can(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisConfigCalibrationLockinTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisConfigCalibrationLockinTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_current(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_current(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_time(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_time(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_distance(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_distance(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_accel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_accel(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_vel(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_vel(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAxisTaskTimesTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAxisTaskTimesTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_thermistor_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_thermistor_update(ptr); break;
            case 1: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_encoder_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_encoder_update(ptr); break;
            case 2: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_sensorless_estimator_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_sensorless_estimator_update(ptr); break;
            case 3: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_endstop_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_endstop_update(ptr); break;
            case 4: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_can_heartbeat(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_can_heartbeat(ptr); break;
            case 5: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_controller_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_controller_update(ptr); break;
            case 6: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_open_loop_controller_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_open_loop_controller_update(ptr); break;
            case 7: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_acim_estimator_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_acim_estimator_update(ptr); break;
            case 8: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_motor_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_motor_update(ptr); break;
            case 9: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_current_controller_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_current_controller_update(ptr); break;
            case 10: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_dc_calib(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_dc_calib(ptr); break;
            case 11: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_current_sense(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_current_sense(ptr); break;
            case 12: *(decltype(ODriveIntf::AxisIntf::TaskTimesIntf::get_pwm_update(std::declval<T*>()))*)(&res) = ODriveIntf::AxisIntf::TaskTimesIntf::get_pwm_update(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveOnboardThermistorCurrentLimiterConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_lower(std::declval<T*>()))*)(&res) = ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_lower(ptr); break;
            case 1: *(decltype(ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_upper(std::declval<T*>()))*)(&res) = ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_upper(ptr); break;
            case 2: *(decltype(ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_enabled(std::declval<T*>()))*)(&res) = ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_enabled(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveOffboardThermistorCurrentLimiterConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_gpio_pin(ptr); break;
            case 1: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_0(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_0(ptr); break;
            case 2: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_1(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_1(ptr); break;
            case 3: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_2(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_2(ptr); break;
            case 4: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_3(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_3(ptr); break;
            case 5: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_lower(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_lower(ptr); break;
            case 6: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_upper(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_upper(ptr); break;
            case 7: *(decltype(ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_enabled(std::declval<T*>()))*)(&res) = ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_enabled(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorCurrentControlTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorCurrentControlTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_p_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_p_gain(ptr); break;
            case 1: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_i_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_i_gain(ptr); break;
            case 2: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_I_measured_report_filter_k(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_I_measured_report_filter_k(ptr); break;
            case 3: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_setpoint(ptr); break;
            case 4: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_setpoint(ptr); break;
            case 5: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Vd_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Vd_setpoint(ptr); break;
            case 6: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Vq_setpoint(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Vq_setpoint(ptr); break;
            case 7: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_phase(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_phase(ptr); break;
            case 8: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_phase_vel(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_phase_vel(ptr); break;
            case 9: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Ialpha_measured(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Ialpha_measured(ptr); break;
            case 10: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Ibeta_measured(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Ibeta_measured(ptr); break;
            case 11: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_measured(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_measured(ptr); break;
            case 12: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_measured(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_measured(ptr); break;
            case 13: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_power(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_power(ptr); break;
            case 14: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_d(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_d(ptr); break;
            case 15: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_q(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_q(ptr); break;
            case 16: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_alpha(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_alpha(ptr); break;
            case 17: *(decltype(ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_beta(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_beta(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMotorConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMotorConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_pre_calibrated(ptr); break;
            case 1: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_pole_pairs(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_pole_pairs(ptr); break;
            case 2: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_calibration_current(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_calibration_current(ptr); break;
            case 3: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_resistance_calib_max_voltage(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_resistance_calib_max_voltage(ptr); break;
            case 4: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_phase_inductance(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_phase_inductance(ptr); break;
            case 5: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_phase_resistance(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_phase_resistance(ptr); break;
            case 6: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_torque_constant(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_torque_constant(ptr); break;
            case 7: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_motor_type(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_motor_type(ptr); break;
            case 8: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_current_lim(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_current_lim(ptr); break;
            case 9: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_current_lim_margin(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_current_lim_margin(ptr); break;
            case 10: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_torque_lim(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_torque_lim(ptr); break;
            case 11: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_lower(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_lower(ptr); break;
            case 12: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_upper(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_upper(ptr); break;
            case 13: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_requested_current_range(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_requested_current_range(ptr); break;
            case 14: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_current_control_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_current_control_bandwidth(ptr); break;
            case 15: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_gain_min_flux(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_gain_min_flux(ptr); break;
            case 16: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_min_Id(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_min_Id(ptr); break;
            case 17: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_enable(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_enable(ptr); break;
            case 18: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_attack_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_attack_gain(ptr); break;
            case 19: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_decay_gain(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_decay_gain(ptr); break;
            case 20: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_R_wL_FF_enable(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_R_wL_FF_enable(ptr); break;
            case 21: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_bEMF_FF_enable(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_bEMF_FF_enable(ptr); break;
            case 22: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_I_bus_hard_min(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_I_bus_hard_min(ptr); break;
            case 23: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_I_bus_hard_max(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_I_bus_hard_max(ptr); break;
            case 24: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_I_leak_max(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_I_leak_max(ptr); break;
            case 25: *(decltype(ODriveIntf::MotorIntf::ConfigIntf::get_dc_calib_tau(std::declval<T*>()))*)(&res) = ODriveIntf::MotorIntf::ConfigIntf::get_dc_calib_tau(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveAcimEstimatorConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveAcimEstimatorConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::AcimEstimatorIntf::ConfigIntf::get_slip_velocity(std::declval<T*>()))*)(&res) = ODriveIntf::AcimEstimatorIntf::ConfigIntf::get_slip_velocity(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveControllerConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveControllerConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_gain_scheduling_width(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_gain_scheduling_width(ptr); break;
            case 1: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_vel_limit(ptr); break;
            case 2: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_torque_mode_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_torque_mode_vel_limit(ptr); break;
            case 3: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_gain_scheduling(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_gain_scheduling(ptr); break;
            case 4: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_enable_overspeed_error(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_enable_overspeed_error(ptr); break;
            case 5: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_control_mode(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_control_mode(ptr); break;
            case 6: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_input_mode(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_input_mode(ptr); break;
            case 7: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_pos_gain(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_pos_gain(ptr); break;
            case 8: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_gain(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_gain(ptr); break;
            case 9: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_gain(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_gain(ptr); break;
            case 10: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_limit(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_limit(ptr); break;
            case 11: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit(ptr); break;
            case 12: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit_tolerance(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit_tolerance(ptr); break;
            case 13: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_vel_ramp_rate(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_vel_ramp_rate(ptr); break;
            case 14: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_torque_ramp_rate(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_torque_ramp_rate(ptr); break;
            case 15: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_circular_setpoints(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_circular_setpoints(ptr); break;
            case 16: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_circular_setpoint_range(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_circular_setpoint_range(ptr); break;
            case 17: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_steps_per_circular_range(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_steps_per_circular_range(ptr); break;
            case 18: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_homing_speed(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_homing_speed(ptr); break;
            case 19: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_inertia(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_inertia(ptr); break;
            case 20: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_axis_to_mirror(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_axis_to_mirror(ptr); break;
            case 21: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_mirror_ratio(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_mirror_ratio(ptr); break;
            case 22: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_torque_mirror_ratio(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_torque_mirror_ratio(ptr); break;
            case 23: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_load_encoder_axis(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_load_encoder_axis(ptr); break;
            case 24: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_input_filter_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_input_filter_bandwidth(ptr); break;
            case 25: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_anticogging(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_anticogging(ptr); break;
            case 26: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_mechanical_power_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_mechanical_power_bandwidth(ptr); break;
            case 27: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_electrical_power_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_electrical_power_bandwidth(ptr); break;
            case 28: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_spinout_mechanical_power_threshold(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_spinout_mechanical_power_threshold(ptr); break;
            case 29: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::get_spinout_electrical_power_threshold(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::get_spinout_electrical_power_threshold(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveControllerConfigAnticoggingTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveControllerConfigAnticoggingTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_index(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_index(ptr); break;
            case 1: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_pre_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_pre_calibrated(ptr); break;
            case 2: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_anticogging(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_anticogging(ptr); break;
            case 3: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_pos_threshold(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_pos_threshold(ptr); break;
            case 4: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_vel_threshold(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_vel_threshold(ptr); break;
            case 5: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_cogging_ratio(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_cogging_ratio(ptr); break;
            case 6: *(decltype(ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_anticogging_enabled(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_anticogging_enabled(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveControllerAutotuningTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveControllerAutotuningTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::ControllerIntf::AutotuningIntf::get_frequency(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::AutotuningIntf::get_frequency(ptr); break;
            case 1: *(decltype(ODriveIntf::ControllerIntf::AutotuningIntf::get_pos_amplitude(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::AutotuningIntf::get_pos_amplitude(ptr); break;
            case 2: *(decltype(ODriveIntf::ControllerIntf::AutotuningIntf::get_vel_amplitude(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::AutotuningIntf::get_vel_amplitude(ptr); break;
            case 3: *(decltype(ODriveIntf::ControllerIntf::AutotuningIntf::get_torque_amplitude(std::declval<T*>()))*)(&res) = ODriveIntf::ControllerIntf::AutotuningIntf::get_torque_amplitude(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEncoderConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEncoderConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_mode(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_mode(ptr); break;
            case 1: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_use_index(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_use_index(ptr); break;
            case 2: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_index_offset(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_index_offset(ptr); break;
            case 3: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_use_index_offset(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_use_index_offset(ptr); break;
            case 4: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_find_idx_on_lockin_only(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_find_idx_on_lockin_only(ptr); break;
            case 5: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_abs_spi_cs_gpio_pin(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_abs_spi_cs_gpio_pin(ptr); break;
            case 6: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_cpr(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_cpr(ptr); break;
            case 7: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_phase_offset(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_phase_offset(ptr); break;
            case 8: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_phase_offset_float(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_phase_offset_float(ptr); break;
            case 9: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_direction(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_direction(ptr); break;
            case 10: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_pre_calibrated(ptr); break;
            case 11: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_enable_phase_interpolation(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_enable_phase_interpolation(ptr); break;
            case 12: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_bandwidth(ptr); break;
            case 13: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_calib_range(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_calib_range(ptr); break;
            case 14: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_distance(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_distance(ptr); break;
            case 15: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_omega(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_omega(ptr); break;
            case 16: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_ignore_illegal_hall_state(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_ignore_illegal_hall_state(ptr); break;
            case 17: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_hall_polarity(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_hall_polarity(ptr); break;
            case 18: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_hall_polarity_calibrated(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_hall_polarity_calibrated(ptr); break;
            case 19: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_sin(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_sin(ptr); break;
            case 20: *(decltype(ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_cos(std::declval<T*>()))*)(&res) = ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_cos(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveSensorlessEstimatorConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveSensorlessEstimatorConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_observer_gain(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_observer_gain(ptr); break;
            case 1: *(decltype(ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pll_bandwidth(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pll_bandwidth(ptr); break;
            case 2: *(decltype(ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pm_flux_linkage(std::declval<T*>()))*)(&res) = ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pm_flux_linkage(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveTrapezoidalTrajectoryConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveTrapezoidalTrajectoryConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_vel_limit(ptr); break;
            case 1: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_accel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_accel_limit(ptr); break;
            case 2: *(decltype(ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_decel_limit(std::declval<T*>()))*)(&res) = ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_decel_limit(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveEndstopConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveEndstopConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_gpio_num(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_gpio_num(ptr); break;
            case 1: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_enabled(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_enabled(ptr); break;
            case 2: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_offset(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_offset(ptr); break;
            case 3: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_is_active_high(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_is_active_high(ptr); break;
            case 4: *(decltype(ODriveIntf::EndstopIntf::ConfigIntf::get_debounce_ms(std::declval<T*>()))*)(&res) = ODriveIntf::EndstopIntf::ConfigIntf::get_debounce_ms(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODriveMechanicalBrakeConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODriveMechanicalBrakeConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODriveIntf::MechanicalBrakeIntf::ConfigIntf::get_gpio_num(std::declval<T*>()))*)(&res) = ODriveIntf::MechanicalBrakeIntf::ConfigIntf::get_gpio_num(ptr); break;
            case 1: *(decltype(ODriveIntf::MechanicalBrakeIntf::ConfigIntf::get_is_active_low(std::declval<T*>()))*)(&res) = ODriveIntf::MechanicalBrakeIntf::ConfigIntf::get_is_active_low(ptr); break;
        }
        return res;
    }
};

template<typename T>
struct ODrive3ConfigTypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const ODrive3ConfigTypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }

    introspectable_storage_t get_child(introspectable_storage_t obj, size_t idx) const override {
        T* ptr = *(T**)&obj;
        introspectable_storage_t res;
        switch (idx) {
            case 0: *(decltype(ODrive3Intf::ConfigIntf::get_enable_uart_a(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_enable_uart_a(ptr); break;
            case 1: *(decltype(ODrive3Intf::ConfigIntf::get_enable_uart_b(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_enable_uart_b(ptr); break;
            case 2: *(decltype(ODrive3Intf::ConfigIntf::get_enable_uart_c(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_enable_uart_c(ptr); break;
            case 3: *(decltype(ODrive3Intf::ConfigIntf::get_uart_a_baudrate(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_uart_a_baudrate(ptr); break;
            case 4: *(decltype(ODrive3Intf::ConfigIntf::get_uart_b_baudrate(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_uart_b_baudrate(ptr); break;
            case 5: *(decltype(ODrive3Intf::ConfigIntf::get_uart_c_baudrate(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_uart_c_baudrate(ptr); break;
            case 6: *(decltype(ODrive3Intf::ConfigIntf::get_enable_can_a(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_enable_can_a(ptr); break;
            case 7: *(decltype(ODrive3Intf::ConfigIntf::get_enable_i2c_a(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_enable_i2c_a(ptr); break;
            case 8: *(decltype(ODrive3Intf::ConfigIntf::get_usb_cdc_protocol(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_usb_cdc_protocol(ptr); break;
            case 9: *(decltype(ODrive3Intf::ConfigIntf::get_uart0_protocol(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_uart0_protocol(ptr); break;
            case 10: *(decltype(ODrive3Intf::ConfigIntf::get_uart1_protocol(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_uart1_protocol(ptr); break;
            case 11: *(decltype(ODrive3Intf::ConfigIntf::get_uart2_protocol(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_uart2_protocol(ptr); break;
            case 12: *(decltype(ODrive3Intf::ConfigIntf::get_max_regen_current(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_max_regen_current(ptr); break;
            case 13: *(decltype(ODrive3Intf::ConfigIntf::get_brake_resistance(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_brake_resistance(ptr); break;
            case 14: *(decltype(ODrive3Intf::ConfigIntf::get_enable_brake_resistor(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_enable_brake_resistor(ptr); break;
            case 15: *(decltype(ODrive3Intf::ConfigIntf::get_dc_bus_undervoltage_trip_level(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_dc_bus_undervoltage_trip_level(ptr); break;
            case 16: *(decltype(ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_trip_level(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_trip_level(ptr); break;
            case 17: *(decltype(ODrive3Intf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(ptr); break;
            case 18: *(decltype(ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(ptr); break;
            case 19: *(decltype(ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(ptr); break;
            case 20: *(decltype(ODrive3Intf::ConfigIntf::get_dc_max_positive_current(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_dc_max_positive_current(ptr); break;
            case 21: *(decltype(ODrive3Intf::ConfigIntf::get_dc_max_negative_current(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_dc_max_negative_current(ptr); break;
            case 22: *(decltype(ODrive3Intf::ConfigIntf::get_error_gpio_pin(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_error_gpio_pin(ptr); break;
            case 23: *(decltype(ODrive3Intf::ConfigIntf::get_gpio3_analog_mapping(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio3_analog_mapping(ptr); break;
            case 24: *(decltype(ODrive3Intf::ConfigIntf::get_gpio4_analog_mapping(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio4_analog_mapping(ptr); break;
            case 25: *(decltype(ODrive3Intf::ConfigIntf::get_gpio1_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio1_mode(ptr); break;
            case 26: *(decltype(ODrive3Intf::ConfigIntf::get_gpio2_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio2_mode(ptr); break;
            case 27: *(decltype(ODrive3Intf::ConfigIntf::get_gpio3_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio3_mode(ptr); break;
            case 28: *(decltype(ODrive3Intf::ConfigIntf::get_gpio4_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio4_mode(ptr); break;
            case 29: *(decltype(ODrive3Intf::ConfigIntf::get_gpio5_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio5_mode(ptr); break;
            case 30: *(decltype(ODrive3Intf::ConfigIntf::get_gpio6_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio6_mode(ptr); break;
            case 31: *(decltype(ODrive3Intf::ConfigIntf::get_gpio7_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio7_mode(ptr); break;
            case 32: *(decltype(ODrive3Intf::ConfigIntf::get_gpio8_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio8_mode(ptr); break;
            case 33: *(decltype(ODrive3Intf::ConfigIntf::get_gpio9_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio9_mode(ptr); break;
            case 34: *(decltype(ODrive3Intf::ConfigIntf::get_gpio10_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio10_mode(ptr); break;
            case 35: *(decltype(ODrive3Intf::ConfigIntf::get_gpio11_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio11_mode(ptr); break;
            case 36: *(decltype(ODrive3Intf::ConfigIntf::get_gpio12_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio12_mode(ptr); break;
            case 37: *(decltype(ODrive3Intf::ConfigIntf::get_gpio13_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio13_mode(ptr); break;
            case 38: *(decltype(ODrive3Intf::ConfigIntf::get_gpio14_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio14_mode(ptr); break;
            case 39: *(decltype(ODrive3Intf::ConfigIntf::get_gpio15_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio15_mode(ptr); break;
            case 40: *(decltype(ODrive3Intf::ConfigIntf::get_gpio16_mode(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio16_mode(ptr); break;
            case 41: *(decltype(ODrive3Intf::ConfigIntf::get_gpio1_pwm_mapping(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio1_pwm_mapping(ptr); break;
            case 42: *(decltype(ODrive3Intf::ConfigIntf::get_gpio2_pwm_mapping(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio2_pwm_mapping(ptr); break;
            case 43: *(decltype(ODrive3Intf::ConfigIntf::get_gpio3_pwm_mapping(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio3_pwm_mapping(ptr); break;
            case 44: *(decltype(ODrive3Intf::ConfigIntf::get_gpio4_pwm_mapping(std::declval<T*>()))*)(&res) = ODrive3Intf::ConfigIntf::get_gpio4_pwm_mapping(ptr); break;
        }
        return res;
    }
};



template<typename T>
const PropertyInfo ODriveTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_error(std::declval<T*>()))>>::singleton},
    {"vbus_voltage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_vbus_voltage(std::declval<T*>()))>>::singleton},
    {"ibus", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_ibus(std::declval<T*>()))>>::singleton},
    {"ibus_report_filter_k", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_ibus_report_filter_k(std::declval<T*>()))>>::singleton},
    {"serial_number", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_serial_number(std::declval<T*>()))>>::singleton},
    {"hw_version_major", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_hw_version_major(std::declval<T*>()))>>::singleton},
    {"hw_version_minor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_hw_version_minor(std::declval<T*>()))>>::singleton},
    {"hw_version_variant", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_hw_version_variant(std::declval<T*>()))>>::singleton},
    {"fw_version_major", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_major(std::declval<T*>()))>>::singleton},
    {"fw_version_minor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_minor(std::declval<T*>()))>>::singleton},
    {"fw_version_revision", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_revision(std::declval<T*>()))>>::singleton},
    {"fw_version_unreleased", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_fw_version_unreleased(std::declval<T*>()))>>::singleton},
    {"brake_resistor_armed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_brake_resistor_armed(std::declval<T*>()))>>::singleton},
    {"brake_resistor_saturated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_brake_resistor_saturated(std::declval<T*>()))>>::singleton},
    {"brake_resistor_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_brake_resistor_current(std::declval<T*>()))>>::singleton},
    {"n_evt_sampling", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_n_evt_sampling(std::declval<T*>()))>>::singleton},
    {"n_evt_control_loop", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_n_evt_control_loop(std::declval<T*>()))>>::singleton},
    {"task_timers_armed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_task_timers_armed(std::declval<T*>()))>>::singleton},
    {"task_times", &ODriveTaskTimesTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_task_times(std::declval<T*>()))>>::singleton},
    {"system_stats", &ODriveSystemStatsTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_system_stats(std::declval<T*>()))>>::singleton},
    {"user_config_loaded", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_user_config_loaded(std::declval<T*>()))>>::singleton},
    {"misconfigured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_misconfigured(std::declval<T*>()))>>::singleton},
    {"oscilloscope", &ODriveOscilloscopeTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_oscilloscope(std::declval<T*>()))>>::singleton},
    {"can", &ODriveCanTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_can(std::declval<T*>()))>>::singleton},
    {"test_property", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_test_property(std::declval<T*>()))>>::singleton},
    {"otp_valid", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::get_otp_valid(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTypeInfo<T> ODriveTypeInfo<T>::singleton{ODriveTypeInfo<T>::property_table, sizeof(ODriveTypeInfo<T>::property_table) / sizeof(ODriveTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveConfigTypeInfo<T>::property_table[] = {
    {"enable_uart_a", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_uart_a(std::declval<T*>()))>>::singleton},
    {"enable_uart_b", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_uart_b(std::declval<T*>()))>>::singleton},
    {"enable_uart_c", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_uart_c(std::declval<T*>()))>>::singleton},
    {"uart_a_baudrate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_uart_a_baudrate(std::declval<T*>()))>>::singleton},
    {"uart_b_baudrate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_uart_b_baudrate(std::declval<T*>()))>>::singleton},
    {"uart_c_baudrate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_uart_c_baudrate(std::declval<T*>()))>>::singleton},
    {"enable_can_a", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_can_a(std::declval<T*>()))>>::singleton},
    {"enable_i2c_a", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_i2c_a(std::declval<T*>()))>>::singleton},
    {"usb_cdc_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_usb_cdc_protocol(std::declval<T*>()))>>::singleton},
    {"uart0_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_uart0_protocol(std::declval<T*>()))>>::singleton},
    {"uart1_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_uart1_protocol(std::declval<T*>()))>>::singleton},
    {"uart2_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_uart2_protocol(std::declval<T*>()))>>::singleton},
    {"max_regen_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_max_regen_current(std::declval<T*>()))>>::singleton},
    {"brake_resistance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_brake_resistance(std::declval<T*>()))>>::singleton},
    {"enable_brake_resistor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_brake_resistor(std::declval<T*>()))>>::singleton},
    {"dc_bus_undervoltage_trip_level", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_undervoltage_trip_level(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_trip_level", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_trip_level(std::declval<T*>()))>>::singleton},
    {"enable_dc_bus_overvoltage_ramp", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_ramp_start", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_ramp_end", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(std::declval<T*>()))>>::singleton},
    {"dc_max_positive_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_max_positive_current(std::declval<T*>()))>>::singleton},
    {"dc_max_negative_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_dc_max_negative_current(std::declval<T*>()))>>::singleton},
    {"error_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_error_gpio_pin(std::declval<T*>()))>>::singleton},
    {"gpio3_analog_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio3_analog_mapping(std::declval<T*>()))>>::singleton},
    {"gpio4_analog_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ConfigIntf::get_gpio4_analog_mapping(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveConfigTypeInfo<T> ODriveConfigTypeInfo<T>::singleton{ODriveConfigTypeInfo<T>::property_table, sizeof(ODriveConfigTypeInfo<T>::property_table) / sizeof(ODriveConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveCanTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::get_error(std::declval<T*>()))>>::singleton},
    {"config", &ODriveCanConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveCanTypeInfo<T> ODriveCanTypeInfo<T>::singleton{ODriveCanTypeInfo<T>::property_table, sizeof(ODriveCanTypeInfo<T>::property_table) / sizeof(ODriveCanTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEndpointTypeInfo<T>::property_table[] = {
    {"endpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndpointIntf::get_endpoint(std::declval<T*>()))>>::singleton},
    {"min", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndpointIntf::get_min(std::declval<T*>()))>>::singleton},
    {"max", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndpointIntf::get_max(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEndpointTypeInfo<T> ODriveEndpointTypeInfo<T>::singleton{ODriveEndpointTypeInfo<T>::property_table, sizeof(ODriveEndpointTypeInfo<T>::property_table) / sizeof(ODriveEndpointTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_error(std::declval<T*>()))>>::singleton},
    {"step_dir_active", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_step_dir_active(std::declval<T*>()))>>::singleton},
    {"last_drv_fault", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_last_drv_fault(std::declval<T*>()))>>::singleton},
    {"steps", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_steps(std::declval<T*>()))>>::singleton},
    {"current_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_current_state(std::declval<T*>()))>>::singleton},
    {"requested_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_requested_state(std::declval<T*>()))>>::singleton},
    {"is_homed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_is_homed(std::declval<T*>()))>>::singleton},
    {"config", &ODriveAxisConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_config(std::declval<T*>()))>>::singleton},
    {"motor", &ODriveMotorTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_motor(std::declval<T*>()))>>::singleton},
    {"controller", &ODriveControllerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_controller(std::declval<T*>()))>>::singleton},
    {"encoder", &ODriveEncoderTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_encoder(std::declval<T*>()))>>::singleton},
    {"acim_estimator", &ODriveAcimEstimatorTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_acim_estimator(std::declval<T*>()))>>::singleton},
    {"sensorless_estimator", &ODriveSensorlessEstimatorTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_sensorless_estimator(std::declval<T*>()))>>::singleton},
    {"trap_traj", &ODriveTrapezoidalTrajectoryTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_trap_traj(std::declval<T*>()))>>::singleton},
    {"min_endstop", &ODriveEndstopTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_min_endstop(std::declval<T*>()))>>::singleton},
    {"max_endstop", &ODriveEndstopTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_max_endstop(std::declval<T*>()))>>::singleton},
    {"mechanical_brake", &ODriveMechanicalBrakeTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_mechanical_brake(std::declval<T*>()))>>::singleton},
    {"task_times", &ODriveAxisTaskTimesTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::get_task_times(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisTypeInfo<T> ODriveAxisTypeInfo<T>::singleton{ODriveAxisTypeInfo<T>::property_table, sizeof(ODriveAxisTypeInfo<T>::property_table) / sizeof(ODriveAxisTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisLockinConfigTypeInfo<T>::property_table[] = {
    {"current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_current(std::declval<T*>()))>>::singleton},
    {"ramp_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_time(std::declval<T*>()))>>::singleton},
    {"ramp_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_ramp_distance(std::declval<T*>()))>>::singleton},
    {"accel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_accel(std::declval<T*>()))>>::singleton},
    {"vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_vel(std::declval<T*>()))>>::singleton},
    {"finish_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_distance(std::declval<T*>()))>>::singleton},
    {"finish_on_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_vel(std::declval<T*>()))>>::singleton},
    {"finish_on_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_distance(std::declval<T*>()))>>::singleton},
    {"finish_on_enc_idx", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::LockinConfigIntf::get_finish_on_enc_idx(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisLockinConfigTypeInfo<T> ODriveAxisLockinConfigTypeInfo<T>::singleton{ODriveAxisLockinConfigTypeInfo<T>::property_table, sizeof(ODriveAxisLockinConfigTypeInfo<T>::property_table) / sizeof(ODriveAxisLockinConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisCanConfigTypeInfo<T>::property_table[] = {
    {"node_id", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_node_id(std::declval<T*>()))>>::singleton},
    {"is_extended", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_is_extended(std::declval<T*>()))>>::singleton},
    {"heartbeat_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_heartbeat_rate_ms(std::declval<T*>()))>>::singleton},
    {"encoder_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_rate_ms(std::declval<T*>()))>>::singleton},
    {"motor_error_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_motor_error_rate_ms(std::declval<T*>()))>>::singleton},
    {"encoder_error_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_error_rate_ms(std::declval<T*>()))>>::singleton},
    {"controller_error_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_controller_error_rate_ms(std::declval<T*>()))>>::singleton},
    {"sensorless_error_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_sensorless_error_rate_ms(std::declval<T*>()))>>::singleton},
    {"encoder_count_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_encoder_count_rate_ms(std::declval<T*>()))>>::singleton},
    {"iq_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_iq_rate_ms(std::declval<T*>()))>>::singleton},
    {"sensorless_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_sensorless_rate_ms(std::declval<T*>()))>>::singleton},
    {"bus_vi_rate_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::CanConfigIntf::get_bus_vi_rate_ms(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisCanConfigTypeInfo<T> ODriveAxisCanConfigTypeInfo<T>::singleton{ODriveAxisCanConfigTypeInfo<T>::property_table, sizeof(ODriveAxisCanConfigTypeInfo<T>::property_table) / sizeof(ODriveAxisCanConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveThermistorCurrentLimiterTypeInfo<T>::property_table[] = {
};
template<typename T>
const ODriveThermistorCurrentLimiterTypeInfo<T> ODriveThermistorCurrentLimiterTypeInfo<T>::singleton{ODriveThermistorCurrentLimiterTypeInfo<T>::property_table, sizeof(ODriveThermistorCurrentLimiterTypeInfo<T>::property_table) / sizeof(ODriveThermistorCurrentLimiterTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveOnboardThermistorCurrentLimiterTypeInfo<T>::property_table[] = {
    {"temperature", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OnboardThermistorCurrentLimiterIntf::get_temperature(std::declval<T*>()))>>::singleton},
    {"config", &ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OnboardThermistorCurrentLimiterIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveOnboardThermistorCurrentLimiterTypeInfo<T> ODriveOnboardThermistorCurrentLimiterTypeInfo<T>::singleton{ODriveOnboardThermistorCurrentLimiterTypeInfo<T>::property_table, sizeof(ODriveOnboardThermistorCurrentLimiterTypeInfo<T>::property_table) / sizeof(ODriveOnboardThermistorCurrentLimiterTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveOffboardThermistorCurrentLimiterTypeInfo<T>::property_table[] = {
    {"temperature", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::get_temperature(std::declval<T*>()))>>::singleton},
    {"config", &ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveOffboardThermistorCurrentLimiterTypeInfo<T> ODriveOffboardThermistorCurrentLimiterTypeInfo<T>::singleton{ODriveOffboardThermistorCurrentLimiterTypeInfo<T>::property_table, sizeof(ODriveOffboardThermistorCurrentLimiterTypeInfo<T>::property_table) / sizeof(ODriveOffboardThermistorCurrentLimiterTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorTypeInfo<T>::property_table[] = {
    {"last_error_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_last_error_time(std::declval<T*>()))>>::singleton},
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_error(std::declval<T*>()))>>::singleton},
    {"is_armed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_is_armed(std::declval<T*>()))>>::singleton},
    {"is_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_is_calibrated(std::declval<T*>()))>>::singleton},
    {"current_meas_phA", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_current_meas_phA(std::declval<T*>()))>>::singleton},
    {"current_meas_phB", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_current_meas_phB(std::declval<T*>()))>>::singleton},
    {"current_meas_phC", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_current_meas_phC(std::declval<T*>()))>>::singleton},
    {"DC_calib_phA", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_DC_calib_phA(std::declval<T*>()))>>::singleton},
    {"DC_calib_phB", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_DC_calib_phB(std::declval<T*>()))>>::singleton},
    {"DC_calib_phC", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_DC_calib_phC(std::declval<T*>()))>>::singleton},
    {"I_bus", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_I_bus(std::declval<T*>()))>>::singleton},
    {"phase_current_rev_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_phase_current_rev_gain(std::declval<T*>()))>>::singleton},
    {"effective_current_lim", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_effective_current_lim(std::declval<T*>()))>>::singleton},
    {"max_allowed_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_max_allowed_current(std::declval<T*>()))>>::singleton},
    {"max_dc_calib", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_max_dc_calib(std::declval<T*>()))>>::singleton},
    {"fet_thermistor", &ODriveOnboardThermistorCurrentLimiterTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_fet_thermistor(std::declval<T*>()))>>::singleton},
    {"motor_thermistor", &ODriveOffboardThermistorCurrentLimiterTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_motor_thermistor(std::declval<T*>()))>>::singleton},
    {"current_control", &ODriveMotorCurrentControlTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_current_control(std::declval<T*>()))>>::singleton},
    {"n_evt_current_measurement", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_n_evt_current_measurement(std::declval<T*>()))>>::singleton},
    {"n_evt_pwm_update", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_n_evt_pwm_update(std::declval<T*>()))>>::singleton},
    {"config", &ODriveMotorConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorTypeInfo<T> ODriveMotorTypeInfo<T>::singleton{ODriveMotorTypeInfo<T>::property_table, sizeof(ODriveMotorTypeInfo<T>::property_table) / sizeof(ODriveMotorTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveOscilloscopeTypeInfo<T>::property_table[] = {
    {"size", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OscilloscopeIntf::get_size(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveOscilloscopeTypeInfo<T> ODriveOscilloscopeTypeInfo<T>::singleton{ODriveOscilloscopeTypeInfo<T>::property_table, sizeof(ODriveOscilloscopeTypeInfo<T>::property_table) / sizeof(ODriveOscilloscopeTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAcimEstimatorTypeInfo<T>::property_table[] = {
    {"rotor_flux", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AcimEstimatorIntf::get_rotor_flux(std::declval<T*>()))>>::singleton},
    {"slip_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AcimEstimatorIntf::get_slip_vel(std::declval<T*>()))>>::singleton},
    {"phase_offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AcimEstimatorIntf::get_phase_offset(std::declval<T*>()))>>::singleton},
    {"stator_phase_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AcimEstimatorIntf::get_stator_phase_vel(std::declval<T*>()))>>::singleton},
    {"stator_phase", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AcimEstimatorIntf::get_stator_phase(std::declval<T*>()))>>::singleton},
    {"config", &ODriveAcimEstimatorConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AcimEstimatorIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAcimEstimatorTypeInfo<T> ODriveAcimEstimatorTypeInfo<T>::singleton{ODriveAcimEstimatorTypeInfo<T>::property_table, sizeof(ODriveAcimEstimatorTypeInfo<T>::property_table) / sizeof(ODriveAcimEstimatorTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveControllerTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_error(std::declval<T*>()))>>::singleton},
    {"last_error_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_last_error_time(std::declval<T*>()))>>::singleton},
    {"input_pos", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_input_pos(std::declval<T*>()))>>::singleton},
    {"input_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_input_vel(std::declval<T*>()))>>::singleton},
    {"input_torque", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_input_torque(std::declval<T*>()))>>::singleton},
    {"pos_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_pos_setpoint(std::declval<T*>()))>>::singleton},
    {"vel_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_vel_setpoint(std::declval<T*>()))>>::singleton},
    {"torque_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_torque_setpoint(std::declval<T*>()))>>::singleton},
    {"trajectory_done", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_trajectory_done(std::declval<T*>()))>>::singleton},
    {"vel_integrator_torque", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_vel_integrator_torque(std::declval<T*>()))>>::singleton},
    {"anticogging_valid", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_anticogging_valid(std::declval<T*>()))>>::singleton},
    {"autotuning_phase", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_autotuning_phase(std::declval<T*>()))>>::singleton},
    {"config", &ODriveControllerConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_config(std::declval<T*>()))>>::singleton},
    {"autotuning", &ODriveControllerAutotuningTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_autotuning(std::declval<T*>()))>>::singleton},
    {"mechanical_power", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_mechanical_power(std::declval<T*>()))>>::singleton},
    {"electrical_power", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::get_electrical_power(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveControllerTypeInfo<T> ODriveControllerTypeInfo<T>::singleton{ODriveControllerTypeInfo<T>::property_table, sizeof(ODriveControllerTypeInfo<T>::property_table) / sizeof(ODriveControllerTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEncoderTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_error(std::declval<T*>()))>>::singleton},
    {"is_ready", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_is_ready(std::declval<T*>()))>>::singleton},
    {"index_found", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_index_found(std::declval<T*>()))>>::singleton},
    {"shadow_count", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_shadow_count(std::declval<T*>()))>>::singleton},
    {"count_in_cpr", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_count_in_cpr(std::declval<T*>()))>>::singleton},
    {"interpolation", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_interpolation(std::declval<T*>()))>>::singleton},
    {"phase", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_phase(std::declval<T*>()))>>::singleton},
    {"pos_estimate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_estimate(std::declval<T*>()))>>::singleton},
    {"pos_estimate_counts", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_estimate_counts(std::declval<T*>()))>>::singleton},
    {"pos_circular", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_circular(std::declval<T*>()))>>::singleton},
    {"pos_cpr_counts", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_cpr_counts(std::declval<T*>()))>>::singleton},
    {"delta_pos_cpr_counts", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_delta_pos_cpr_counts(std::declval<T*>()))>>::singleton},
    {"hall_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_hall_state(std::declval<T*>()))>>::singleton},
    {"vel_estimate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_vel_estimate(std::declval<T*>()))>>::singleton},
    {"vel_estimate_counts", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_vel_estimate_counts(std::declval<T*>()))>>::singleton},
    {"calib_scan_response", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_calib_scan_response(std::declval<T*>()))>>::singleton},
    {"pos_abs", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_pos_abs(std::declval<T*>()))>>::singleton},
    {"spi_error_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_spi_error_rate(std::declval<T*>()))>>::singleton},
    {"config", &ODriveEncoderConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEncoderTypeInfo<T> ODriveEncoderTypeInfo<T>::singleton{ODriveEncoderTypeInfo<T>::property_table, sizeof(ODriveEncoderTypeInfo<T>::property_table) / sizeof(ODriveEncoderTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSensorlessEstimatorTypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_error(std::declval<T*>()))>>::singleton},
    {"phase", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_phase(std::declval<T*>()))>>::singleton},
    {"pll_pos", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_pll_pos(std::declval<T*>()))>>::singleton},
    {"phase_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_phase_vel(std::declval<T*>()))>>::singleton},
    {"vel_estimate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_vel_estimate(std::declval<T*>()))>>::singleton},
    {"config", &ODriveSensorlessEstimatorConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSensorlessEstimatorTypeInfo<T> ODriveSensorlessEstimatorTypeInfo<T>::singleton{ODriveSensorlessEstimatorTypeInfo<T>::property_table, sizeof(ODriveSensorlessEstimatorTypeInfo<T>::property_table) / sizeof(ODriveSensorlessEstimatorTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table[] = {
    {"config", &ODriveTrapezoidalTrajectoryConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTrapezoidalTrajectoryTypeInfo<T> ODriveTrapezoidalTrajectoryTypeInfo<T>::singleton{ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table, sizeof(ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table) / sizeof(ODriveTrapezoidalTrajectoryTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEndstopTypeInfo<T>::property_table[] = {
    {"endstop_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::get_endstop_state(std::declval<T*>()))>>::singleton},
    {"config", &ODriveEndstopConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEndstopTypeInfo<T> ODriveEndstopTypeInfo<T>::singleton{ODriveEndstopTypeInfo<T>::property_table, sizeof(ODriveEndstopTypeInfo<T>::property_table) / sizeof(ODriveEndstopTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMechanicalBrakeTypeInfo<T>::property_table[] = {
    {"config", &ODriveMechanicalBrakeConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MechanicalBrakeIntf::get_config(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMechanicalBrakeTypeInfo<T> ODriveMechanicalBrakeTypeInfo<T>::singleton{ODriveMechanicalBrakeTypeInfo<T>::property_table, sizeof(ODriveMechanicalBrakeTypeInfo<T>::property_table) / sizeof(ODriveMechanicalBrakeTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveTaskTimerTypeInfo<T>::property_table[] = {
    {"start_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimerIntf::get_start_time(std::declval<T*>()))>>::singleton},
    {"end_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimerIntf::get_end_time(std::declval<T*>()))>>::singleton},
    {"length", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimerIntf::get_length(std::declval<T*>()))>>::singleton},
    {"max_length", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimerIntf::get_max_length(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTaskTimerTypeInfo<T> ODriveTaskTimerTypeInfo<T>::singleton{ODriveTaskTimerTypeInfo<T>::property_table, sizeof(ODriveTaskTimerTypeInfo<T>::property_table) / sizeof(ODriveTaskTimerTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODrive3TypeInfo<T>::property_table[] = {
    {"error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_error(std::declval<T*>()))>>::singleton},
    {"vbus_voltage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_vbus_voltage(std::declval<T*>()))>>::singleton},
    {"ibus", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_ibus(std::declval<T*>()))>>::singleton},
    {"ibus_report_filter_k", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_ibus_report_filter_k(std::declval<T*>()))>>::singleton},
    {"serial_number", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_serial_number(std::declval<T*>()))>>::singleton},
    {"hw_version_major", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_hw_version_major(std::declval<T*>()))>>::singleton},
    {"hw_version_minor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_hw_version_minor(std::declval<T*>()))>>::singleton},
    {"hw_version_variant", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_hw_version_variant(std::declval<T*>()))>>::singleton},
    {"fw_version_major", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_fw_version_major(std::declval<T*>()))>>::singleton},
    {"fw_version_minor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_fw_version_minor(std::declval<T*>()))>>::singleton},
    {"fw_version_revision", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_fw_version_revision(std::declval<T*>()))>>::singleton},
    {"fw_version_unreleased", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_fw_version_unreleased(std::declval<T*>()))>>::singleton},
    {"brake_resistor_armed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_brake_resistor_armed(std::declval<T*>()))>>::singleton},
    {"brake_resistor_saturated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_brake_resistor_saturated(std::declval<T*>()))>>::singleton},
    {"brake_resistor_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_brake_resistor_current(std::declval<T*>()))>>::singleton},
    {"n_evt_sampling", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_n_evt_sampling(std::declval<T*>()))>>::singleton},
    {"n_evt_control_loop", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_n_evt_control_loop(std::declval<T*>()))>>::singleton},
    {"task_timers_armed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_task_timers_armed(std::declval<T*>()))>>::singleton},
    {"task_times", &ODriveTaskTimesTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_task_times(std::declval<T*>()))>>::singleton},
    {"system_stats", &ODriveSystemStatsTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_system_stats(std::declval<T*>()))>>::singleton},
    {"user_config_loaded", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_user_config_loaded(std::declval<T*>()))>>::singleton},
    {"misconfigured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_misconfigured(std::declval<T*>()))>>::singleton},
    {"oscilloscope", &ODriveOscilloscopeTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_oscilloscope(std::declval<T*>()))>>::singleton},
    {"can", &ODriveCanTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_can(std::declval<T*>()))>>::singleton},
    {"test_property", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_test_property(std::declval<T*>()))>>::singleton},
    {"otp_valid", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_otp_valid(std::declval<T*>()))>>::singleton},
    {"config", &ODrive3ConfigTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_config(std::declval<T*>()))>>::singleton},
    {"axis0", &ODriveAxisTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_axis0(std::declval<T*>()))>>::singleton},
    {"axis1", &ODriveAxisTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::get_axis1(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODrive3TypeInfo<T> ODrive3TypeInfo<T>::singleton{ODrive3TypeInfo<T>::property_table, sizeof(ODrive3TypeInfo<T>::property_table) / sizeof(ODrive3TypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveTaskTimesTypeInfo<T>::property_table[] = {
    {"sampling", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimesIntf::get_sampling(std::declval<T*>()))>>::singleton},
    {"control_loop_misc", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimesIntf::get_control_loop_misc(std::declval<T*>()))>>::singleton},
    {"control_loop_checks", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimesIntf::get_control_loop_checks(std::declval<T*>()))>>::singleton},
    {"dc_calib_wait", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TaskTimesIntf::get_dc_calib_wait(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTaskTimesTypeInfo<T> ODriveTaskTimesTypeInfo<T>::singleton{ODriveTaskTimesTypeInfo<T>::property_table, sizeof(ODriveTaskTimesTypeInfo<T>::property_table) / sizeof(ODriveTaskTimesTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSystemStatsTypeInfo<T>::property_table[] = {
    {"uptime", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_uptime(std::declval<T*>()))>>::singleton},
    {"min_heap_space", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_min_heap_space(std::declval<T*>()))>>::singleton},
    {"max_stack_usage_axis", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_max_stack_usage_axis(std::declval<T*>()))>>::singleton},
    {"max_stack_usage_usb", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_max_stack_usage_usb(std::declval<T*>()))>>::singleton},
    {"max_stack_usage_uart", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_max_stack_usage_uart(std::declval<T*>()))>>::singleton},
    {"max_stack_usage_can", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_max_stack_usage_can(std::declval<T*>()))>>::singleton},
    {"max_stack_usage_startup", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_max_stack_usage_startup(std::declval<T*>()))>>::singleton},
    {"max_stack_usage_analog", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_max_stack_usage_analog(std::declval<T*>()))>>::singleton},
    {"stack_size_axis", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_size_axis(std::declval<T*>()))>>::singleton},
    {"stack_size_usb", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_size_usb(std::declval<T*>()))>>::singleton},
    {"stack_size_uart", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_size_uart(std::declval<T*>()))>>::singleton},
    {"stack_size_startup", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_size_startup(std::declval<T*>()))>>::singleton},
    {"stack_size_can", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_size_can(std::declval<T*>()))>>::singleton},
    {"stack_size_analog", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_stack_size_analog(std::declval<T*>()))>>::singleton},
    {"prio_axis", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_prio_axis(std::declval<T*>()))>>::singleton},
    {"prio_usb", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_prio_usb(std::declval<T*>()))>>::singleton},
    {"prio_uart", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_prio_uart(std::declval<T*>()))>>::singleton},
    {"prio_startup", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_prio_startup(std::declval<T*>()))>>::singleton},
    {"prio_can", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_prio_can(std::declval<T*>()))>>::singleton},
    {"prio_analog", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_prio_analog(std::declval<T*>()))>>::singleton},
    {"usb", &ODriveSystemStatsUsbTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_usb(std::declval<T*>()))>>::singleton},
    {"i2c", &ODriveSystemStatsI2CTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::get_i2c(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSystemStatsTypeInfo<T> ODriveSystemStatsTypeInfo<T>::singleton{ODriveSystemStatsTypeInfo<T>::property_table, sizeof(ODriveSystemStatsTypeInfo<T>::property_table) / sizeof(ODriveSystemStatsTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSystemStatsUsbTypeInfo<T>::property_table[] = {
    {"rx_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::UsbIntf::get_rx_cnt(std::declval<T*>()))>>::singleton},
    {"tx_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_cnt(std::declval<T*>()))>>::singleton},
    {"tx_overrun_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::UsbIntf::get_tx_overrun_cnt(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSystemStatsUsbTypeInfo<T> ODriveSystemStatsUsbTypeInfo<T>::singleton{ODriveSystemStatsUsbTypeInfo<T>::property_table, sizeof(ODriveSystemStatsUsbTypeInfo<T>::property_table) / sizeof(ODriveSystemStatsUsbTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSystemStatsI2CTypeInfo<T>::property_table[] = {
    {"addr", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_addr(std::declval<T*>()))>>::singleton},
    {"addr_match_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_addr_match_cnt(std::declval<T*>()))>>::singleton},
    {"rx_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_rx_cnt(std::declval<T*>()))>>::singleton},
    {"error_cnt", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SystemStatsIntf::I2CIntf::get_error_cnt(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSystemStatsI2CTypeInfo<T> ODriveSystemStatsI2CTypeInfo<T>::singleton{ODriveSystemStatsI2CTypeInfo<T>::property_table, sizeof(ODriveSystemStatsI2CTypeInfo<T>::property_table) / sizeof(ODriveSystemStatsI2CTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveCanConfigTypeInfo<T>::property_table[] = {
    {"baud_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::ConfigIntf::get_baud_rate(std::declval<T*>()))>>::singleton},
    {"protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::CanIntf::ConfigIntf::get_protocol(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveCanConfigTypeInfo<T> ODriveCanConfigTypeInfo<T>::singleton{ODriveCanConfigTypeInfo<T>::property_table, sizeof(ODriveCanConfigTypeInfo<T>::property_table) / sizeof(ODriveCanConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisConfigTypeInfo<T>::property_table[] = {
    {"startup_motor_calibration", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_motor_calibration(std::declval<T*>()))>>::singleton},
    {"startup_encoder_index_search", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_index_search(std::declval<T*>()))>>::singleton},
    {"startup_encoder_offset_calibration", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_encoder_offset_calibration(std::declval<T*>()))>>::singleton},
    {"startup_closed_loop_control", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_closed_loop_control(std::declval<T*>()))>>::singleton},
    {"startup_homing", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_startup_homing(std::declval<T*>()))>>::singleton},
    {"enable_step_dir", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_enable_step_dir(std::declval<T*>()))>>::singleton},
    {"step_dir_always_on", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_step_dir_always_on(std::declval<T*>()))>>::singleton},
    {"enable_sensorless_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_enable_sensorless_mode(std::declval<T*>()))>>::singleton},
    {"watchdog_timeout", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_watchdog_timeout(std::declval<T*>()))>>::singleton},
    {"enable_watchdog", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_enable_watchdog(std::declval<T*>()))>>::singleton},
    {"step_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_step_gpio_pin(std::declval<T*>()))>>::singleton},
    {"dir_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_dir_gpio_pin(std::declval<T*>()))>>::singleton},
    {"calibration_lockin", &ODriveAxisConfigCalibrationLockinTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_calibration_lockin(std::declval<T*>()))>>::singleton},
    {"sensorless_ramp", &ODriveAxisLockinConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_sensorless_ramp(std::declval<T*>()))>>::singleton},
    {"general_lockin", &ODriveAxisLockinConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_general_lockin(std::declval<T*>()))>>::singleton},
    {"can", &ODriveAxisCanConfigTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::get_can(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisConfigTypeInfo<T> ODriveAxisConfigTypeInfo<T>::singleton{ODriveAxisConfigTypeInfo<T>::property_table, sizeof(ODriveAxisConfigTypeInfo<T>::property_table) / sizeof(ODriveAxisConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table[] = {
    {"current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_current(std::declval<T*>()))>>::singleton},
    {"ramp_time", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_time(std::declval<T*>()))>>::singleton},
    {"ramp_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_ramp_distance(std::declval<T*>()))>>::singleton},
    {"accel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_accel(std::declval<T*>()))>>::singleton},
    {"vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::ConfigIntf::CalibrationLockinIntf::get_vel(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisConfigCalibrationLockinTypeInfo<T> ODriveAxisConfigCalibrationLockinTypeInfo<T>::singleton{ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table, sizeof(ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table) / sizeof(ODriveAxisConfigCalibrationLockinTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAxisTaskTimesTypeInfo<T>::property_table[] = {
    {"thermistor_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_thermistor_update(std::declval<T*>()))>>::singleton},
    {"encoder_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_encoder_update(std::declval<T*>()))>>::singleton},
    {"sensorless_estimator_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_sensorless_estimator_update(std::declval<T*>()))>>::singleton},
    {"endstop_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_endstop_update(std::declval<T*>()))>>::singleton},
    {"can_heartbeat", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_can_heartbeat(std::declval<T*>()))>>::singleton},
    {"controller_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_controller_update(std::declval<T*>()))>>::singleton},
    {"open_loop_controller_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_open_loop_controller_update(std::declval<T*>()))>>::singleton},
    {"acim_estimator_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_acim_estimator_update(std::declval<T*>()))>>::singleton},
    {"motor_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_motor_update(std::declval<T*>()))>>::singleton},
    {"current_controller_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_current_controller_update(std::declval<T*>()))>>::singleton},
    {"dc_calib", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_dc_calib(std::declval<T*>()))>>::singleton},
    {"current_sense", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_current_sense(std::declval<T*>()))>>::singleton},
    {"pwm_update", &ODriveTaskTimerTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AxisIntf::TaskTimesIntf::get_pwm_update(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAxisTaskTimesTypeInfo<T> ODriveAxisTaskTimesTypeInfo<T>::singleton{ODriveAxisTaskTimesTypeInfo<T>::property_table, sizeof(ODriveAxisTaskTimesTypeInfo<T>::property_table) / sizeof(ODriveAxisTaskTimesTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table[] = {
    {"temp_limit_lower", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_lower(std::declval<T*>()))>>::singleton},
    {"temp_limit_upper", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_upper(std::declval<T*>()))>>::singleton},
    {"enabled", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OnboardThermistorCurrentLimiterIntf::ConfigIntf::get_enabled(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<T> ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<T>::singleton{ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table, sizeof(ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table) / sizeof(ODriveOnboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table[] = {
    {"gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_gpio_pin(std::declval<T*>()))>>::singleton},
    {"poly_coefficient_0", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_0(std::declval<T*>()))>>::singleton},
    {"poly_coefficient_1", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_1(std::declval<T*>()))>>::singleton},
    {"poly_coefficient_2", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_2(std::declval<T*>()))>>::singleton},
    {"poly_coefficient_3", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_poly_coefficient_3(std::declval<T*>()))>>::singleton},
    {"temp_limit_lower", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_lower(std::declval<T*>()))>>::singleton},
    {"temp_limit_upper", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_temp_limit_upper(std::declval<T*>()))>>::singleton},
    {"enabled", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::OffboardThermistorCurrentLimiterIntf::ConfigIntf::get_enabled(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<T> ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<T>::singleton{ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table, sizeof(ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table) / sizeof(ODriveOffboardThermistorCurrentLimiterConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorCurrentControlTypeInfo<T>::property_table[] = {
    {"p_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_p_gain(std::declval<T*>()))>>::singleton},
    {"i_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_i_gain(std::declval<T*>()))>>::singleton},
    {"I_measured_report_filter_k", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_I_measured_report_filter_k(std::declval<T*>()))>>::singleton},
    {"Id_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_setpoint(std::declval<T*>()))>>::singleton},
    {"Iq_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_setpoint(std::declval<T*>()))>>::singleton},
    {"Vd_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Vd_setpoint(std::declval<T*>()))>>::singleton},
    {"Vq_setpoint", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Vq_setpoint(std::declval<T*>()))>>::singleton},
    {"phase", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_phase(std::declval<T*>()))>>::singleton},
    {"phase_vel", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_phase_vel(std::declval<T*>()))>>::singleton},
    {"Ialpha_measured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Ialpha_measured(std::declval<T*>()))>>::singleton},
    {"Ibeta_measured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Ibeta_measured(std::declval<T*>()))>>::singleton},
    {"Id_measured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Id_measured(std::declval<T*>()))>>::singleton},
    {"Iq_measured", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_Iq_measured(std::declval<T*>()))>>::singleton},
    {"power", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_power(std::declval<T*>()))>>::singleton},
    {"v_current_control_integral_d", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_d(std::declval<T*>()))>>::singleton},
    {"v_current_control_integral_q", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_v_current_control_integral_q(std::declval<T*>()))>>::singleton},
    {"final_v_alpha", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_alpha(std::declval<T*>()))>>::singleton},
    {"final_v_beta", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::CurrentControlIntf::get_final_v_beta(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorCurrentControlTypeInfo<T> ODriveMotorCurrentControlTypeInfo<T>::singleton{ODriveMotorCurrentControlTypeInfo<T>::property_table, sizeof(ODriveMotorCurrentControlTypeInfo<T>::property_table) / sizeof(ODriveMotorCurrentControlTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMotorConfigTypeInfo<T>::property_table[] = {
    {"pre_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))>>::singleton},
    {"pole_pairs", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_pole_pairs(std::declval<T*>()))>>::singleton},
    {"calibration_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_calibration_current(std::declval<T*>()))>>::singleton},
    {"resistance_calib_max_voltage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_resistance_calib_max_voltage(std::declval<T*>()))>>::singleton},
    {"phase_inductance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_phase_inductance(std::declval<T*>()))>>::singleton},
    {"phase_resistance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_phase_resistance(std::declval<T*>()))>>::singleton},
    {"torque_constant", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_torque_constant(std::declval<T*>()))>>::singleton},
    {"motor_type", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_motor_type(std::declval<T*>()))>>::singleton},
    {"current_lim", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_current_lim(std::declval<T*>()))>>::singleton},
    {"current_lim_margin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_current_lim_margin(std::declval<T*>()))>>::singleton},
    {"torque_lim", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_torque_lim(std::declval<T*>()))>>::singleton},
    {"inverter_temp_limit_lower", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_lower(std::declval<T*>()))>>::singleton},
    {"inverter_temp_limit_upper", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_inverter_temp_limit_upper(std::declval<T*>()))>>::singleton},
    {"requested_current_range", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_requested_current_range(std::declval<T*>()))>>::singleton},
    {"current_control_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_current_control_bandwidth(std::declval<T*>()))>>::singleton},
    {"acim_gain_min_flux", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_gain_min_flux(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_min_Id", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_min_Id(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_enable", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_enable(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_attack_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_attack_gain(std::declval<T*>()))>>::singleton},
    {"acim_autoflux_decay_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_acim_autoflux_decay_gain(std::declval<T*>()))>>::singleton},
    {"R_wL_FF_enable", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_R_wL_FF_enable(std::declval<T*>()))>>::singleton},
    {"bEMF_FF_enable", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_bEMF_FF_enable(std::declval<T*>()))>>::singleton},
    {"I_bus_hard_min", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_I_bus_hard_min(std::declval<T*>()))>>::singleton},
    {"I_bus_hard_max", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_I_bus_hard_max(std::declval<T*>()))>>::singleton},
    {"I_leak_max", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_I_leak_max(std::declval<T*>()))>>::singleton},
    {"dc_calib_tau", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MotorIntf::ConfigIntf::get_dc_calib_tau(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMotorConfigTypeInfo<T> ODriveMotorConfigTypeInfo<T>::singleton{ODriveMotorConfigTypeInfo<T>::property_table, sizeof(ODriveMotorConfigTypeInfo<T>::property_table) / sizeof(ODriveMotorConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveAcimEstimatorConfigTypeInfo<T>::property_table[] = {
    {"slip_velocity", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::AcimEstimatorIntf::ConfigIntf::get_slip_velocity(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveAcimEstimatorConfigTypeInfo<T> ODriveAcimEstimatorConfigTypeInfo<T>::singleton{ODriveAcimEstimatorConfigTypeInfo<T>::property_table, sizeof(ODriveAcimEstimatorConfigTypeInfo<T>::property_table) / sizeof(ODriveAcimEstimatorConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveControllerConfigTypeInfo<T>::property_table[] = {
    {"gain_scheduling_width", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_gain_scheduling_width(std::declval<T*>()))>>::singleton},
    {"enable_vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_vel_limit(std::declval<T*>()))>>::singleton},
    {"enable_torque_mode_vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_torque_mode_vel_limit(std::declval<T*>()))>>::singleton},
    {"enable_gain_scheduling", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_gain_scheduling(std::declval<T*>()))>>::singleton},
    {"enable_overspeed_error", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_enable_overspeed_error(std::declval<T*>()))>>::singleton},
    {"control_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_control_mode(std::declval<T*>()))>>::singleton},
    {"input_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_input_mode(std::declval<T*>()))>>::singleton},
    {"pos_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_pos_gain(std::declval<T*>()))>>::singleton},
    {"vel_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_gain(std::declval<T*>()))>>::singleton},
    {"vel_integrator_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_gain(std::declval<T*>()))>>::singleton},
    {"vel_integrator_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_integrator_limit(std::declval<T*>()))>>::singleton},
    {"vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))>>::singleton},
    {"vel_limit_tolerance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_limit_tolerance(std::declval<T*>()))>>::singleton},
    {"vel_ramp_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_vel_ramp_rate(std::declval<T*>()))>>::singleton},
    {"torque_ramp_rate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_torque_ramp_rate(std::declval<T*>()))>>::singleton},
    {"circular_setpoints", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_circular_setpoints(std::declval<T*>()))>>::singleton},
    {"circular_setpoint_range", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_circular_setpoint_range(std::declval<T*>()))>>::singleton},
    {"steps_per_circular_range", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_steps_per_circular_range(std::declval<T*>()))>>::singleton},
    {"homing_speed", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_homing_speed(std::declval<T*>()))>>::singleton},
    {"inertia", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_inertia(std::declval<T*>()))>>::singleton},
    {"axis_to_mirror", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_axis_to_mirror(std::declval<T*>()))>>::singleton},
    {"mirror_ratio", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_mirror_ratio(std::declval<T*>()))>>::singleton},
    {"torque_mirror_ratio", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_torque_mirror_ratio(std::declval<T*>()))>>::singleton},
    {"load_encoder_axis", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_load_encoder_axis(std::declval<T*>()))>>::singleton},
    {"input_filter_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_input_filter_bandwidth(std::declval<T*>()))>>::singleton},
    {"anticogging", &ODriveControllerConfigAnticoggingTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_anticogging(std::declval<T*>()))>>::singleton},
    {"mechanical_power_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_mechanical_power_bandwidth(std::declval<T*>()))>>::singleton},
    {"electrical_power_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_electrical_power_bandwidth(std::declval<T*>()))>>::singleton},
    {"spinout_mechanical_power_threshold", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_spinout_mechanical_power_threshold(std::declval<T*>()))>>::singleton},
    {"spinout_electrical_power_threshold", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::get_spinout_electrical_power_threshold(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveControllerConfigTypeInfo<T> ODriveControllerConfigTypeInfo<T>::singleton{ODriveControllerConfigTypeInfo<T>::property_table, sizeof(ODriveControllerConfigTypeInfo<T>::property_table) / sizeof(ODriveControllerConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveControllerConfigAnticoggingTypeInfo<T>::property_table[] = {
    {"index", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_index(std::declval<T*>()))>>::singleton},
    {"pre_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_pre_calibrated(std::declval<T*>()))>>::singleton},
    {"calib_anticogging", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_anticogging(std::declval<T*>()))>>::singleton},
    {"calib_pos_threshold", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_pos_threshold(std::declval<T*>()))>>::singleton},
    {"calib_vel_threshold", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_calib_vel_threshold(std::declval<T*>()))>>::singleton},
    {"cogging_ratio", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_cogging_ratio(std::declval<T*>()))>>::singleton},
    {"anticogging_enabled", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::ConfigIntf::AnticoggingIntf::get_anticogging_enabled(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveControllerConfigAnticoggingTypeInfo<T> ODriveControllerConfigAnticoggingTypeInfo<T>::singleton{ODriveControllerConfigAnticoggingTypeInfo<T>::property_table, sizeof(ODriveControllerConfigAnticoggingTypeInfo<T>::property_table) / sizeof(ODriveControllerConfigAnticoggingTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveControllerAutotuningTypeInfo<T>::property_table[] = {
    {"frequency", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::AutotuningIntf::get_frequency(std::declval<T*>()))>>::singleton},
    {"pos_amplitude", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::AutotuningIntf::get_pos_amplitude(std::declval<T*>()))>>::singleton},
    {"vel_amplitude", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::AutotuningIntf::get_vel_amplitude(std::declval<T*>()))>>::singleton},
    {"torque_amplitude", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::ControllerIntf::AutotuningIntf::get_torque_amplitude(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveControllerAutotuningTypeInfo<T> ODriveControllerAutotuningTypeInfo<T>::singleton{ODriveControllerAutotuningTypeInfo<T>::property_table, sizeof(ODriveControllerAutotuningTypeInfo<T>::property_table) / sizeof(ODriveControllerAutotuningTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEncoderConfigTypeInfo<T>::property_table[] = {
    {"mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_mode(std::declval<T*>()))>>::singleton},
    {"use_index", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_use_index(std::declval<T*>()))>>::singleton},
    {"index_offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_index_offset(std::declval<T*>()))>>::singleton},
    {"use_index_offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_use_index_offset(std::declval<T*>()))>>::singleton},
    {"find_idx_on_lockin_only", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_find_idx_on_lockin_only(std::declval<T*>()))>>::singleton},
    {"abs_spi_cs_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_abs_spi_cs_gpio_pin(std::declval<T*>()))>>::singleton},
    {"cpr", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_cpr(std::declval<T*>()))>>::singleton},
    {"phase_offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_phase_offset(std::declval<T*>()))>>::singleton},
    {"phase_offset_float", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_phase_offset_float(std::declval<T*>()))>>::singleton},
    {"direction", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_direction(std::declval<T*>()))>>::singleton},
    {"pre_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_pre_calibrated(std::declval<T*>()))>>::singleton},
    {"enable_phase_interpolation", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_enable_phase_interpolation(std::declval<T*>()))>>::singleton},
    {"bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_bandwidth(std::declval<T*>()))>>::singleton},
    {"calib_range", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_calib_range(std::declval<T*>()))>>::singleton},
    {"calib_scan_distance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_distance(std::declval<T*>()))>>::singleton},
    {"calib_scan_omega", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_calib_scan_omega(std::declval<T*>()))>>::singleton},
    {"ignore_illegal_hall_state", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_ignore_illegal_hall_state(std::declval<T*>()))>>::singleton},
    {"hall_polarity", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_hall_polarity(std::declval<T*>()))>>::singleton},
    {"hall_polarity_calibrated", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_hall_polarity_calibrated(std::declval<T*>()))>>::singleton},
    {"sincos_gpio_pin_sin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_sin(std::declval<T*>()))>>::singleton},
    {"sincos_gpio_pin_cos", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EncoderIntf::ConfigIntf::get_sincos_gpio_pin_cos(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEncoderConfigTypeInfo<T> ODriveEncoderConfigTypeInfo<T>::singleton{ODriveEncoderConfigTypeInfo<T>::property_table, sizeof(ODriveEncoderConfigTypeInfo<T>::property_table) / sizeof(ODriveEncoderConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table[] = {
    {"observer_gain", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_observer_gain(std::declval<T*>()))>>::singleton},
    {"pll_bandwidth", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pll_bandwidth(std::declval<T*>()))>>::singleton},
    {"pm_flux_linkage", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::SensorlessEstimatorIntf::ConfigIntf::get_pm_flux_linkage(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveSensorlessEstimatorConfigTypeInfo<T> ODriveSensorlessEstimatorConfigTypeInfo<T>::singleton{ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table, sizeof(ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table) / sizeof(ODriveSensorlessEstimatorConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table[] = {
    {"vel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_vel_limit(std::declval<T*>()))>>::singleton},
    {"accel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_accel_limit(std::declval<T*>()))>>::singleton},
    {"decel_limit", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::TrapezoidalTrajectoryIntf::ConfigIntf::get_decel_limit(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveTrapezoidalTrajectoryConfigTypeInfo<T> ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::singleton{ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table, sizeof(ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table) / sizeof(ODriveTrapezoidalTrajectoryConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveEndstopConfigTypeInfo<T>::property_table[] = {
    {"gpio_num", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_gpio_num(std::declval<T*>()))>>::singleton},
    {"enabled", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_enabled(std::declval<T*>()))>>::singleton},
    {"offset", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_offset(std::declval<T*>()))>>::singleton},
    {"is_active_high", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_is_active_high(std::declval<T*>()))>>::singleton},
    {"debounce_ms", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::EndstopIntf::ConfigIntf::get_debounce_ms(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveEndstopConfigTypeInfo<T> ODriveEndstopConfigTypeInfo<T>::singleton{ODriveEndstopConfigTypeInfo<T>::property_table, sizeof(ODriveEndstopConfigTypeInfo<T>::property_table) / sizeof(ODriveEndstopConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODriveMechanicalBrakeConfigTypeInfo<T>::property_table[] = {
    {"gpio_num", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MechanicalBrakeIntf::ConfigIntf::get_gpio_num(std::declval<T*>()))>>::singleton},
    {"is_active_low", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODriveIntf::MechanicalBrakeIntf::ConfigIntf::get_is_active_low(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODriveMechanicalBrakeConfigTypeInfo<T> ODriveMechanicalBrakeConfigTypeInfo<T>::singleton{ODriveMechanicalBrakeConfigTypeInfo<T>::property_table, sizeof(ODriveMechanicalBrakeConfigTypeInfo<T>::property_table) / sizeof(ODriveMechanicalBrakeConfigTypeInfo<T>::property_table[0])};


template<typename T>
const PropertyInfo ODrive3ConfigTypeInfo<T>::property_table[] = {
    {"enable_uart_a", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_enable_uart_a(std::declval<T*>()))>>::singleton},
    {"enable_uart_b", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_enable_uart_b(std::declval<T*>()))>>::singleton},
    {"enable_uart_c", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_enable_uart_c(std::declval<T*>()))>>::singleton},
    {"uart_a_baudrate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_uart_a_baudrate(std::declval<T*>()))>>::singleton},
    {"uart_b_baudrate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_uart_b_baudrate(std::declval<T*>()))>>::singleton},
    {"uart_c_baudrate", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_uart_c_baudrate(std::declval<T*>()))>>::singleton},
    {"enable_can_a", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_enable_can_a(std::declval<T*>()))>>::singleton},
    {"enable_i2c_a", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_enable_i2c_a(std::declval<T*>()))>>::singleton},
    {"usb_cdc_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_usb_cdc_protocol(std::declval<T*>()))>>::singleton},
    {"uart0_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_uart0_protocol(std::declval<T*>()))>>::singleton},
    {"uart1_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_uart1_protocol(std::declval<T*>()))>>::singleton},
    {"uart2_protocol", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_uart2_protocol(std::declval<T*>()))>>::singleton},
    {"max_regen_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_max_regen_current(std::declval<T*>()))>>::singleton},
    {"brake_resistance", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_brake_resistance(std::declval<T*>()))>>::singleton},
    {"enable_brake_resistor", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_enable_brake_resistor(std::declval<T*>()))>>::singleton},
    {"dc_bus_undervoltage_trip_level", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_dc_bus_undervoltage_trip_level(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_trip_level", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_trip_level(std::declval<T*>()))>>::singleton},
    {"enable_dc_bus_overvoltage_ramp", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_enable_dc_bus_overvoltage_ramp(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_ramp_start", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_ramp_start(std::declval<T*>()))>>::singleton},
    {"dc_bus_overvoltage_ramp_end", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_dc_bus_overvoltage_ramp_end(std::declval<T*>()))>>::singleton},
    {"dc_max_positive_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_dc_max_positive_current(std::declval<T*>()))>>::singleton},
    {"dc_max_negative_current", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_dc_max_negative_current(std::declval<T*>()))>>::singleton},
    {"error_gpio_pin", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_error_gpio_pin(std::declval<T*>()))>>::singleton},
    {"gpio3_analog_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio3_analog_mapping(std::declval<T*>()))>>::singleton},
    {"gpio4_analog_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio4_analog_mapping(std::declval<T*>()))>>::singleton},
    {"gpio1_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio1_mode(std::declval<T*>()))>>::singleton},
    {"gpio2_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio2_mode(std::declval<T*>()))>>::singleton},
    {"gpio3_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio3_mode(std::declval<T*>()))>>::singleton},
    {"gpio4_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio4_mode(std::declval<T*>()))>>::singleton},
    {"gpio5_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio5_mode(std::declval<T*>()))>>::singleton},
    {"gpio6_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio6_mode(std::declval<T*>()))>>::singleton},
    {"gpio7_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio7_mode(std::declval<T*>()))>>::singleton},
    {"gpio8_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio8_mode(std::declval<T*>()))>>::singleton},
    {"gpio9_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio9_mode(std::declval<T*>()))>>::singleton},
    {"gpio10_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio10_mode(std::declval<T*>()))>>::singleton},
    {"gpio11_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio11_mode(std::declval<T*>()))>>::singleton},
    {"gpio12_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio12_mode(std::declval<T*>()))>>::singleton},
    {"gpio13_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio13_mode(std::declval<T*>()))>>::singleton},
    {"gpio14_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio14_mode(std::declval<T*>()))>>::singleton},
    {"gpio15_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio15_mode(std::declval<T*>()))>>::singleton},
    {"gpio16_mode", &FibrePropertyTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio16_mode(std::declval<T*>()))>>::singleton},
    {"gpio1_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio1_pwm_mapping(std::declval<T*>()))>>::singleton},
    {"gpio2_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio2_pwm_mapping(std::declval<T*>()))>>::singleton},
    {"gpio3_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio3_pwm_mapping(std::declval<T*>()))>>::singleton},
    {"gpio4_pwm_mapping", &ODriveEndpointTypeInfo<std::remove_reference_t<decltype(*ODrive3Intf::ConfigIntf::get_gpio4_pwm_mapping(std::declval<T*>()))>>::singleton},
};
template<typename T>
const ODrive3ConfigTypeInfo<T> ODrive3ConfigTypeInfo<T>::singleton{ODrive3ConfigTypeInfo<T>::property_table, sizeof(ODrive3ConfigTypeInfo<T>::property_table) / sizeof(ODrive3ConfigTypeInfo<T>::property_table[0])};



#pragma GCC pop_options